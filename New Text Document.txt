package com.optum.fads.caseentrybatch.api.config;

import org.quartz.CronScheduleBuilder;
import org.quartz.JobBuilder;
import org.quartz.JobDetail;
import org.quartz.Trigger;
import org.quartz.TriggerBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.optum.fads.caseentrybatch.api.job.CaseEntryBatchJob;
import com.optum.fads.caseentrybatch.api.repo.CaseConfigRepository;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Configuration
public class CaseEntryBatchJobConfig {
	private static final String BATCH_CASE_SCHEDULE = "BATCH_CASE_ENTRY_SCHEDULE";
	
	@Autowired
	private CaseConfigRepository caseConfigTRepository;
	
	@Bean
	public JobDetail caseBatchJobDetails() {
		
	//	return JobBuilder.newJob(casebatchJob.class).withIdentity("casebatchJob").usingJobData("casebatchJobDetail", "test")
		return JobBuilder.newJob(CaseEntryBatchJob.class).withIdentity("caseEntryBatchJob")
				.storeDurably().build();
	}

	@Bean
	public Trigger caseBatchJobTrigger() {
		String batchCaseCronDb = caseConfigTRepository.getOptionValue(BATCH_CASE_SCHEDULE);
		
		log.info("casebatchJobTrigger set up with Cron Expression " + batchCaseCronDb);
		return TriggerBuilder.newTrigger().forJob(caseBatchJobDetails()).withIdentity("CaseBatchJobTrigger", "CaseBatchGroup")
				.withSchedule(CronScheduleBuilder.cronSchedule(batchCaseCronDb)).build();
	}
	
	
}
/*
//***********************************************
// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/

package com.optum.fads.caseentrybatch.api.config;

import com.azure.identity.ClientSecretCredentialBuilder;
import com.azure.security.keyvault.secrets.SecretClient;
import com.azure.identity.ClientSecretCredential;
import com.azure.security.keyvault.secrets.SecretClientBuilder;
import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import static org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE;

/**
 * The CommonConfig holds spring based configuration
 */
@Configuration
public class CommonConfig {

    @Value("${spring.cloud.azure.keyvault.secrets.endpoint}")
    private String azureKeyVaultUrl;
    @Value("${spring.cloud.azure.keyvault.credential.tenant-id}")
    private String azureKeyVaultTenant;
    @Value("${spring.cloud.azure.keyvault.credential.client-secret}")
    private String azureKeyVaultSecret;
    @Value("${spring.cloud.azure.keyvault.credential.client-id}")
    private String azureKeyVaultClientId;

    /**
     * Model Mapper for mapping objects
     *
     * @return modelMapper
     */
    @Bean
    @Scope(SCOPE_PROTOTYPE)
    public ModelMapper modelMapper() {
        final var modelMapper = new ModelMapper();
        modelMapper.getConfiguration().setAmbiguityIgnored(true);
        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
        return modelMapper;
    }

    @Bean
    public SecretClient secretClient() {
        ClientSecretCredential clientSecretCredential = new ClientSecretCredentialBuilder()
                .clientId(azureKeyVaultClientId)
                .clientSecret(azureKeyVaultSecret)
                .tenantId(azureKeyVaultTenant)
                .build();

        return new SecretClientBuilder()
                .vaultUrl(azureKeyVaultUrl)
                .credential(clientSecretCredential)
                .buildClient();
    }
}
package com.optum.fads.caseentrybatch.api.config;

import java.io.StringReader;
import java.security.PrivateKey;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.spec.RSAPrivateCrtKeySpec;
import net.snowflake.client.jdbc.internal.org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import net.snowflake.client.jdbc.internal.org.bouncycastle.jce.provider.BouncyCastleProvider;
import net.snowflake.client.jdbc.internal.org.bouncycastle.openssl.PEMEncryptedKeyPair;
import net.snowflake.client.jdbc.internal.org.bouncycastle.openssl.PEMParser;
import net.snowflake.client.jdbc.internal.org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import net.snowflake.client.jdbc.internal.org.bouncycastle.openssl.jcajce.JceOpenSSLPKCS8DecryptorProviderBuilder;
import net.snowflake.client.jdbc.internal.org.bouncycastle.operator.InputDecryptorProvider;
import net.snowflake.client.jdbc.internal.org.bouncycastle.pkcs.PKCS8EncryptedPrivateKeyInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.Security;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.spec.RSAPrivateCrtKeySpec;


public class PemKeyLoader {
    private static final Logger logger =
            LoggerFactory.getLogger(PemKeyLoader.class);

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    public static PrivateKey loadPrivateKeyPem(String pemContent, char[] passphrase) throws Exception {
        logger.debug("Parsing PEM content...");
        try (PEMParser pemParser = new PEMParser(new StringReader(pemContent))) {
            Object pemObject = pemParser.readObject();
            PrivateKeyInfo privateKeyInfo = null;

            if (pemObject instanceof PKCS8EncryptedPrivateKeyInfo) {
                if (passphrase == null) {
                    throw new IllegalArgumentException(
                            "Encrypted key found but no passphrase provided."
                    );
                }
                logger.debug("Detected PKCS#8 encrypted key.");
                PKCS8EncryptedPrivateKeyInfo encInfo =
                        (PKCS8EncryptedPrivateKeyInfo) pemObject;
                InputDecryptorProvider decProv =
                        new JceOpenSSLPKCS8DecryptorProviderBuilder().build(passphrase);
                privateKeyInfo = encInfo.decryptPrivateKeyInfo(decProv);

            } else if (pemObject instanceof PEMEncryptedKeyPair) {
                logger.debug("Detected old-format encrypted key (PEM).");
                // Add necessary decryption if needed
            } else if (pemObject instanceof PrivateKeyInfo) {
                logger.debug("Detected unencrypted PKCS#8 key.");
                privateKeyInfo = (PrivateKeyInfo) pemObject;
            } else {
                logger.debug("Unknown PEM object type: {}",
                        pemObject == null ? "null" : pemObject.getClass().getName());
            }

            // Convert to BC key first
            JcaPEMKeyConverter converter = new JcaPEMKeyConverter()
                    .setProvider(BouncyCastleProvider.PROVIDER_NAME);
            PrivateKey bcKey = converter.getPrivateKey(privateKeyInfo);

            // Convert BC key to standard JDK RSA key
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey) bcKey;

            RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(
                    rsaKey.getModulus(),
                    rsaKey.getPublicExponent(),
                    rsaKey.getPrivateExponent(),
                    rsaKey.getPrimeP(),
                    rsaKey.getPrimeQ(),
                    rsaKey.getPrimeExponentP(),
                    rsaKey.getPrimeExponentQ(),
                    rsaKey.getCrtCoefficient()
            );

            PrivateKey jdkKey = keyFactory.generatePrivate(keySpec);
            logger.debug("Key conversion successfull ***");

            return jdkKey;
        }
    }
}

package com.optum.fads.caseentrybatch.api.config;

import java.io.IOException;
import java.security.PrivateKey;
import java.util.HashMap;
import java.util.Properties;

import javax.sql.DataSource;

import org.bouncycastle.pkcs.PKCSException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.azure.security.keyvault.secrets.SecretClient;
import com.zaxxer.hikari.HikariDataSource;

import jakarta.persistence.EntityManagerFactory;
import net.snowflake.client.jdbc.SnowflakeBasicDataSource;

/**
 * @author sbajaj8
 *
 */
@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
@EnableTransactionManagement
@EnableJpaRepositories(entityManagerFactoryRef = "snfkEntityManagerFactory",
						transactionManagerRef = "txManagerSnFk",
						basePackages = {"com.optum.fads.caseentrybatch.api.snowflakeRepo"}
						)
public class ServiceConfig 
{
    private static final Logger logger =
            LoggerFactory.getLogger(ServiceConfig.class);

	
	@Value("${spring.datasource.snfk.jdbcUrl}")
    private String url;

    @Value("${spring.datasource.snfk.userName}")
    private String username;

    @Value("${spring.datasource.snfk.password}")
    private String password;

    @Value("${spring.datasource.snfk.certKey}")
    private String certKey;

    @Value("${spring.datasource.snfk.passphrase}")
    private String passphrase;

    @Value("${spring.datasource.snfk.database}")
    private String database;

    @Value("${spring.datasource.snfk.schema}")
    private String schema;

    @Value("${spring.datasource.snfk.warehouse}")
    private String warehouse;

    @Value("${spring.datasource.snfk.account}")
    private String account;
    
    @Value("${spring.datasource.snfk.role}")
    private String role;

    @Value("${db.snfk-login.useCert}")
    private Boolean useCert;

    private final SecretClient secretClient;

    public ServiceConfig(SecretClient secretClient) {
        this.secretClient = secretClient;
    }
	
    @Primary
	@Bean(name="fadsDataSource")
    public DataSource customDataSource() throws Exception, IOException {
        if(useCert){
            String pemContent = secretClient.getSecret(certKey).getValue();
            logger.info("snowflake login using certificate");

            char[] password = secretClient.getSecret(passphrase).getValue()  != null ? secretClient.getSecret(passphrase).getValue().toCharArray() : null;
            PrivateKey privateKey = PemKeyLoader.loadPrivateKeyPem(pemContent, password);
            // Add more logging
            logger.info("Private key class: {}", privateKey.getClass().getName());
            logger.info("Private key implements RSAPrivateCrtKey? {}", privateKey instanceof java.security.interfaces.RSAPrivateCrtKey);

            SnowflakeBasicDataSource dataSource = new SnowflakeBasicDataSource();

            dataSource.setUrl(url);
            dataSource.setDatabaseName(database);
            dataSource.setSchema(schema);
            dataSource.setWarehouse(warehouse);
            if(account != null && !account.isEmpty()) {
                dataSource.setAccount(account);
            }
            if(role != null && !role.isEmpty()) {
                dataSource.setRole(role);
            }

            dataSource.setUser(username);
            dataSource.setPrivateKey(privateKey);

            HikariDataSource hikariDs = new HikariDataSource();
            hikariDs.setDataSource(dataSource);

            return hikariDs;

        } else {
            String user = secretClient.getSecret(username).getValue();
            String pass = secretClient.getSecret(password).getValue();
            logger.info("snowflake login using username and password");
            Properties props = new Properties();
            props.put("user", user);
            props.put("password", pass);
            props.put("database", database);
            props.put("schema", schema);
            props.put("warehouse", warehouse);
            if(role != null && !role.isEmpty()){
                props.put("role", role);
            }
            if(account != null && !account.isEmpty()){
                props.put("account", account);
            }
            return new DriverManagerDataSource(url, props);
        }

    }
	
    @Primary
	@Bean("snfkEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean 
    snfkEntityManagerFactory( ) throws IOException, PKCSException, Exception
	 {
	  LocalContainerEntityManagerFactoryBean em
	          = new LocalContainerEntityManagerFactoryBean();
	        em.setDataSource(customDataSource());
	        em.setPackagesToScan(
	          new String[] { "com.optum.fads.caseentrybatch.api.snowflakeDomain" });
	        HibernateJpaVendorAdapter vendorAdapter
	          = new HibernateJpaVendorAdapter();
	        em.setJpaVendorAdapter(vendorAdapter);
	        HashMap<String, Object> properties = new HashMap<>();
	        properties.put("hibernate.allow_update_outside_transaction",true);
	        properties.put("hibernate.dialect", "com.optum.fads.caseentrybatch.api.config.SnowflakeDialect");
	        em.setJpaPropertyMap(properties);
	    return em;
	}
	
    @Primary
	@Bean ("txManagerSnFk")
	public PlatformTransactionManager txManagerSnFk(@Qualifier("snfkEntityManagerFactory")EntityManagerFactory snfkEntityManagerFactory) throws IOException, PKCSException, Exception
	 {
    	JpaTransactionManager txManager = new JpaTransactionManager();
        txManager.setEntityManagerFactory(snfkEntityManagerFactory().getObject());
        return txManager;
	 }

    @Bean(name = "jdbcSnowflake")
    public JdbcTemplate snowflakeJdbcTemplate(@Qualifier("fadsDataSource") DataSource dsSlave) {
        return new JdbcTemplate(dsSlave);
    }
	}


	

package com.optum.fads.caseentrybatch.api.config;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.azure.security.keyvault.secrets.SecretClient;

import jakarta.persistence.EntityManagerFactory;

/**
 * @author sbajaj8
 *
 */
@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
@EnableTransactionManagement
@EnableJpaRepositories(entityManagerFactoryRef = "sqlEntityManagerFactory",
						transactionManagerRef = "txManagerSQL",
						basePackages = "com.optum.fads.caseentrybatch.api.repo" )
		public class ServiceConfigSQL 
		{
			@Value("${spring.datasource.sql.userName}")
			private String userName;

			@Value("${spring.datasource.sql.password}")
			private String password;

			@Value("${spring.datasource.sql.jdbcUrl}")
			private String url;

			@Value("${spring.datasource.sql.driverClassName}")
			private String driverClassName;

			private final SecretClient secretClient;

			public ServiceConfigSQL(SecretClient secretClient) {
				this.secretClient = secretClient;
			}

			@Primary
			@Bean(name = "fadsSQLDataSource")
			public DataSource fadsSQLDataSource() {
				String userNameValue = secretClient.getSecret(userName).getValue();
				String passwordValue = secretClient.getSecret(password).getValue();

				DriverManagerDataSource dataSource = new DriverManagerDataSource();
				dataSource.setDriverClassName(driverClassName);
				dataSource.setUsername(userNameValue);
				dataSource.setPassword(passwordValue);
				dataSource.setUrl(url);

				return dataSource;
			}
	
			@Bean(name = "sqlEntityManagerFactory")
				public LocalContainerEntityManagerFactoryBean sqlEntityManagerFactory()
					{
						LocalContainerEntityManagerFactoryBean em
								= new LocalContainerEntityManagerFactoryBean();
						em.setDataSource(fadsSQLDataSource());
						em.setPackagesToScan(
								new String[] { "com.optum.fads.caseentrybatch.api.domain" });
						HibernateJpaVendorAdapter vendorAdapter
							= new HibernateJpaVendorAdapter();
						em.setJpaVendorAdapter(vendorAdapter);
					return em;
					}
	 
	 
	 @Bean(name = "txManagerSQL")
	 public PlatformTransactionManager txManagerSQL(@Qualifier("sqlEntityManagerFactory")EntityManagerFactory sqlEntityManagerFactory)
	 {
		 JpaTransactionManager txManager = new JpaTransactionManager();
	        txManager.setEntityManagerFactory(sqlEntityManagerFactory().getObject());
	        return txManager;
	 }
	 
	}


	


package com.optum.fads.caseentrybatch.api.config;

import org.hibernate.dialect.Dialect;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SnowflakeDialect extends Dialect {

}
