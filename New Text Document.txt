package com.optum.fads.pgp.behavior.api.config;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import com.nimbusds.jwt.JWT;
import com.nimbusds.jwt.JWTParser;
import com.optum.fads.pgp.behavior.api.security.UserJwtAuthenticationConverter;
import com.optum.fads.pgp.behavior.api.service.IUserDetailsService;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
	private static final String CSP_DEFAULT = "default-src 'none'; connect-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline' 'unsafe-eval';";
	private final IUserDetailsService userDetailsService;
	
	@Value("${spring.security.oauth2.resourceserver.jwt.unique-id-claims}")
	private List<String> uniqueIdClaims;

	public SecurityConfig(IUserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}
	private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);

	 @Bean
	    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {


		 http.csrf(csrf -> csrf
						 .ignoringRequestMatchers("/actuator/**", "/api/**")
				 )
				 .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
				 .authorizeHttpRequests(auth -> auth.requestMatchers("/actuator/**").permitAll()
						 .anyRequest().authenticated())
				 .oauth2ResourceServer(oauth2 -> oauth2
						 .jwt(jwt -> jwt
								 .decoder(jwtDecoder())
								 .jwtAuthenticationConverter(userJwtAuthenticationConverter())
						 )
				 );
	                
	        return http.build();
	    }

	@Bean
	public JwtDecoder jwtDecoder() {
		// Custom JWT decoder that skips signature validation
		return token -> {
			try {
				JWT jwt = JWTParser.parse(token);

				// Convert claims, handling Date to Instant conversion
				Map<String, Object> claims = new HashMap<>(jwt.getJWTClaimsSet().getClaims());

				convertDateToInstant(claims, "iat");  // issued at
				convertDateToInstant(claims, "exp");  // expires at
				convertDateToInstant(claims, "nbf");  // not before
				convertDateToInstant(claims, "auth_time");  // authentication time

				return Jwt.withTokenValue(token)
						.headers(headers -> headers.putAll(jwt.getHeader().toJSONObject()))
						.claims(claimsMap -> claimsMap.putAll(claims))
						.build();
			} catch (Exception e) {
				throw new JwtException("Failed to parse JWT", e);
			}
		};
	}

	private void convertDateToInstant(Map<String, Object> claims, String claimName) {
		Object value = claims.get(claimName);
		if (value instanceof Date) {
			claims.put(claimName, ((Date) value).toInstant());
		}
	}

	@Bean
	UserJwtAuthenticationConverter userJwtAuthenticationConverter() {
		logger.debug("Creating UserJwtAuthenticationConverter bean");
		return new UserJwtAuthenticationConverter(userDetailsService, uniqueIdClaims);
	}

	@Bean
	PasswordEncoder passwordEncoder() {
		logger.debug("Creating PasswordEncoder bean using DelegatingPasswordEncoder");
		 return PasswordEncoderFactories.createDelegatingPasswordEncoder();
	}

	@Bean
	CorsConfigurationSource corsConfigurationSource() {
		logger.debug("Creating CorsConfigurationSource bean");
		CorsConfiguration configuration = new CorsConfiguration();
		configuration.setAllowedOrigins(Collections.singletonList(CorsConfiguration.ALL));
		configuration.setAllowedMethods(Collections.singletonList(CorsConfiguration.ALL));
		configuration.setAllowedHeaders(Collections.singletonList(CorsConfiguration.ALL));
	//	configuration.setAllowCredentials(true);
		UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
		source.registerCorsConfiguration("/**", configuration);
		logger.info("CORS configuration registered for all paths");
		return source;
	}
	
}


package com.optum.fads.pgp.behavior.api.security;


import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;

import com.optum.fads.pgp.behavior.api.service.IUserDetailsService;

//@SuppressWarnings("unused")
public class UserJwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken>{

	private static final String GROUPS_CLAIM = "groups";
	private static final String ROLE_PREFIX = "ROLE_";

	private final IUserDetailsService userDetailsService;
	private final List<String> uniqueIdClaims;

	public UserJwtAuthenticationConverter(IUserDetailsService userDetailsService, List<String> uniqueIdClaims) {
		this.userDetailsService = userDetailsService;
		this.uniqueIdClaims = uniqueIdClaims;
		
	}

	@Override
	public AbstractAuthenticationToken convert(Jwt jwt) {
		Collection<GrantedAuthority> authorities = extractAuthorities(jwt);
		return Optional.ofNullable(userDetailsService.loadUserByUsername(getUniqueID(jwt)))
				.map(u -> new UsernamePasswordAuthenticationToken(u, "n/a", authorities))
				.orElseThrow(() -> new BadCredentialsException("No user found"));
	}

	private Collection<GrantedAuthority> extractAuthorities(Jwt jwt) {
		return this.getGroups(jwt).stream().map(authority -> ROLE_PREFIX + authority.toUpperCase())
				.map(SimpleGrantedAuthority::new).collect(Collectors.toList());
	}

	@SuppressWarnings("unchecked")
	private Collection<String> getGroups(Jwt jwt) {
		Object groups = jwt.getClaims().get(GROUPS_CLAIM);
		if (groups instanceof Collection) {
			return (Collection<String>) groups;
		}

		return Collections.emptyList();
	}
	private String getUniqueID(Jwt jwt) {
		return uniqueIdClaims.stream()
				.map(jwt::getClaimAsString)
				.filter(v -> v != null && !v.isBlank())
				.findFirst()
				.orElse(null);
	}
	
	
}
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.14.1:testCompile (default-testCompile) on project fads-pgp-behavior-api: Compilation failure: Compilation failure:
[ERROR] /C:/Users/sgupt664/BE_Projects/fads-pgp-behavior-api/src/test/java/com/optum/fads/pgp/behavior/api/security/UserJwtAuthenticationConverterTest.java:[41,17] constructor UserJwtAuthenticationConverter in class com.optum.fads.pgp.behavior.api.security.UserJwtAuthenticationConverter cannot be applied to given types;
[ERROR]   required: com.optum.fads.pgp.behavior.api.service.IUserDetailsService,java.util.List<java.lang.String>
[ERROR]   found:    com.optum.fads.pgp.behavior.api.service.IUserDetailsService
[ERROR]   reason: actual and formal argument lists differ in length
[ERROR] /C:/Users/sgupt664/BE_Projects/fads-pgp-behavior-api/src/test/java/com/optum/fads/pgp/behavior/api/security/UserJwtAuthenticationConverterTest.java:[65,17] constructor UserJwtAuthenticationConverter in class com.optum.fads.pgp.behavior.api.security.UserJwtAuthenticationConverter cannot be applied to given types;
[ERROR]   required: com.optum.fads.pgp.behavior.api.service.IUserDetailsService,java.util.List<java.lang.String>
[ERROR]   found:    com.optum.fads.pgp.behavior.api.service.IUserDetailsService
[ERROR]   reason: actual and formal argument lists differ in length
[ERROR] -> [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException

C:\Users\sgupt664\BE_Projects\fads-pgp-behavior-api>
