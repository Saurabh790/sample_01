<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <contextName>${APPNAME_ENV}</contextName>
    <springProperty name="application.name" source="spring.application.name"/>
    <springProperty name="audit.application.name" source="audit.application.name"/>
    <springProperty name="audit.log.type" source="audit.log.type"/>

    <property name="CONSOLE_LOG_PATTERN"
              value="${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd'T'HH:mm:ss.SSSXXX}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>
    <property name="FILE_LOG_PATTERN"
              value="${FILE_LOG_PATTERN:-%d{yyyy-MM-dd'T'HH:mm:ss.SSSXXX} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}"/>

    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    <property name="LOG_FILE" value="${LOG_FILE:-${LOG_PATH:-${LOG_TEMP:-${java.io.tmpdir:-/tmp}}}/spring.log}"/>

    <include resource="org/springframework/boot/logging/logback/console-appender.xml"/>
    <include resource="org/springframework/boot/logging/logback/file-appender.xml"/>

    <!-- Audit file contains all 'AUDIT' logger INFO messages, and all application ERROR message -->
    <appender name="AUDIT" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <filter class="ch.qos.logback.core.filter.EvaluatorFilter">
            <evaluator>
                <expression>
                    return (level >= INFO &amp;&amp; "AUDIT".equals(logger)) ||
                        (level >= ERROR &amp;&amp; logger.startsWith("com.optum.fads.study"));
                </expression>
            </evaluator>
            <OnMismatch>DENY</OnMismatch>
            <OnMatch>NEUTRAL</OnMatch>
        </filter>
        <encoder>
            <pattern>
                %n${AUDIT_LOG_PATTERN:-%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd'T'HH:mm:ss.SSSXXX}}|%level|${audit.application.name}|${audit.log.type}|%X{clientIp}|%X{sourceIp}|%X{userId}|%X{authorizedUser} %m}
            </pattern>
        </encoder>
        <file>logs/${application.name}/audit/${application.name}_audit.log
        </file>
        <rollingPolicy
                class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
            <fileNamePattern>logs/${application.name}/audit/${application.name}_audit.log.%i
            </fileNamePattern>
        </rollingPolicy>
        <triggeringPolicy
                class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>10MB</MaxFileSize>
        </triggeringPolicy>
    </appender>

    <appender name="JSON" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/${application.name}/json/${application.name}_json.log
        </file>
        <rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy">
            <fileNamePattern>logs/${application.name}/json/${application.name}_json.log.%i</fileNamePattern>
        </rollingPolicy>
        <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
            <MaxFileSize>10MB</MaxFileSize>
        </triggeringPolicy>
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp>
                    <fieldName>timestamp</fieldName>
                    <timeZone>UTC</timeZone>
                </timestamp>
                <pattern>
                    <pattern>
                        {
                            "level": "%level",
                            "context": "${HOSTNAME}-%thread",
                            "logger": "%logger{40}",
                            "message": "%message",
                            "exception": "${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"
                        }
                    </pattern>
                </pattern>
            </providers>
        </encoder>
    </appender>

    <!-- INFO log statements go to audit log, console, and application log files -->
    <root level="INFO">
        <appender-ref ref="AUDIT"/>
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
        <appender-ref ref="JSON"/>
    </root>
</configuration>



















above is logback file , belwo is application yaml file 




server:
  port: 8080
  servlet:
    contextPath: /behavior
quickstart:
  generateOrderPeriod: 10s
  processOrderPeriod: 30s

spring:
  application:
   name: behavior
  jpa:
    database-platform: org.hibernate.dialect.SQLServer2016Dialect
    database: SQL_SERVER 
    show-sql: false
    hibernate:
       naming:
            implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyHbmImpl
            physical-strategy: org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    jdbcUrl: jdbc:sqlserver://wn000054716:1433;databaseName=fadsdb;encrypt=true;trustServerCertificate=true;
    userName: fads_dev
    password: qAut9fM.S!g3?385
    driverClassName: com.microsoft.sqlserver.jdbc.SQLServerDriver
    hikari:
      maximum-pool-size: ${MAXIMUM_DB_POOL_SIZE:50}
      minimum-idle: ${MIN_POOL_IDLE:1}
      connection-timeout: ${DB_CONNECTION_TIMEOUT:60000}
      idle-timeout: ${DB_POOL_IDLE_TIMEOUT:60000}
      leak-detection-threshold: ${LEAK_DETETCTION_THRESHOLD:0}
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: https://login.microsoftonline.com/fbe00597-ca09-441a-836a-eb0dcb7c14e1/discovery/v2.0/keys
          jws-algorithms: RS256
management:
  endpoint:
    metrics.enabled: true
    prometheus.enabled: true
  endpoints.web.exposure.include:
    - health
    - info
    - prometheus
  prometheus.metrics.export.enabled: true
#logging:
#  level:
#    org:
#      hibernate:
#        SQL: DEBUG
#        type: TRACE







below is my controller


/*
//***********************************************
// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/

package com.optum.fads.pgp.behavior.api.controller;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.optum.fads.pgp.behavior.api.common.ListTableParams;
import com.optum.fads.pgp.behavior.api.common.ListTableParamsReq;
import com.optum.fads.pgp.behavior.api.common.constants.BehaviorPatternConstants;
import com.optum.fads.pgp.behavior.api.dto.AppUser;
import com.optum.fads.pgp.behavior.api.dto.BehaviorPatternDTO;
import com.optum.fads.pgp.behavior.api.dto.DataRuleDTO;
import com.optum.fads.pgp.behavior.api.dto.PaginationResult;
import com.optum.fads.pgp.behavior.api.exception.BehaviorPatternApiException;
import com.optum.fads.pgp.behavior.api.service.IBehaviorPatternDataService;
import com.optum.fads.pgp.behavior.api.dto.AccessLevel;

/**
 * Use this class to add the methods so that a single web service can be used to
 * get and update the FADS Behavior Pattern data
 *
 ** @author Anil Wagh
 */
@Component
@RestController
//@RequestMapping("/behavior")
@CrossOrigin
public class BehaviorPatternController {

	private static final Logger logit = LoggerFactory.getLogger(BehaviorPatternController.class);

	@Autowired
	private IBehaviorPatternDataService iBehaviorPatternDataService;

	final String[] DISALLOWED_FIELDS = new String[]{"listTableParams.selectedItemIds"};
	    
	    @InitBinder(value = "listTableParams")
	    void initListTableParamsValidator(WebDataBinder binder) {
	        binder.setDisallowedFields(DISALLOWED_FIELDS);
	    }
	    
	/**
	 * this method will give all the Behavior Pattern data or records per page
	 * 
	 * @param - ListTableParams (contains sort, filter conditions; page number, page
	 *          size)
	 */
	@GetMapping(value = "/getbehaviorpatterns/**", headers = "Accept=application/json")
	public ResponseEntity getBehaviorPatterns(ListTableParamsReq listTableParamsReq,String searchInput) {
		PaginationResult paginationResult;
		try {
			ListTableParams listTableParams=new ListTableParams();
			listTableParams.setPageNumber(listTableParamsReq.getPageNumber());
			listTableParams.setRecordsPerPage(listTableParamsReq.getRecordsPerPage());
			listTableParams.setSearchBy(listTableParamsReq.getSearchBy());
			listTableParams.setSearchInput(Collections.singletonList(searchInput));
			listTableParams.setSelectedItemIds(listTableParamsReq.getSelectedItemIds());
			listTableParams.setSortBy(listTableParamsReq.getSortBy());
			listTableParams.setSortOrder(listTableParamsReq.getSortOrder());
			paginationResult = iBehaviorPatternDataService.getBehaviorPatternsList(listTableParams); // get behavior
																										// patterns
		} catch (BehaviorPatternApiException ex) {
			logit.error(BehaviorPatternConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(BehaviorPatternConstants.EXCEPTION_MESSAGE);
		}
		return ResponseEntity.status(HttpStatus.OK).body(paginationResult);
	}

	/**
	 * this method will get the behavior pattern record corresponding to input
	 * behavior pattern ID
	 * 
	 * @param - Behavior Pattern ID
	 */
	@GetMapping(value = "/getbehaviorpatterndetails/{behaviorpatternId}")
	public ResponseEntity getBehaviorpatternById(@PathVariable(name = "behaviorpatternId") Integer behaviorPatternId)

	{
		BehaviorPatternDTO behaviorPatternDTO = null;
		try {
			behaviorPatternDTO = iBehaviorPatternDataService.getBehaviorPatternById(behaviorPatternId);
		} catch (BehaviorPatternApiException ex) {
			logit.error(ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Behavior Pattern ID not found");
		}
		return ResponseEntity.status(HttpStatus.OK).body(behaviorPatternDTO);
	}

	/**
	 * this method will get the available Data Rule records
	 * 
	 * @param - ER ID (Extact Rule ID)
	 */
	@GetMapping(value = { "/getavailabledatarules/{extractRuleId}" })
	public ResponseEntity getAvailableDatarules(@PathVariable(name = "extractRuleId") Integer extractRuleId) {
		List<DataRuleDTO> availableDatarulesList;
		try {
			availableDatarulesList = iBehaviorPatternDataService.getAvailableDatarules(extractRuleId);
		} catch (BehaviorPatternApiException ex) {
			logit.error(BehaviorPatternConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(BehaviorPatternConstants.EXCEPTION_MESSAGE);
		}
		return ResponseEntity.status(HttpStatus.OK).body(availableDatarulesList);
	}

	/**
	 * this method will get the selected Data Rule records for a behavior pattern
	 * 
	 * @param - ER ID (Extact Rule ID)
	 */
	@GetMapping(value = { "/getselecteddatarules/{extractRuleId}" })
	public ResponseEntity getSelectedDatarules(@PathVariable(name = "extractRuleId") Integer extractRuleId) {
		List<DataRuleDTO> selectedDataRulesList;
		boolean details = false;
		try {
			selectedDataRulesList = iBehaviorPatternDataService.getSelectedDataRules(extractRuleId, details);
		} catch (BehaviorPatternApiException ex) {
			logit.error(BehaviorPatternConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(BehaviorPatternConstants.EXCEPTION_MESSAGE);
		}
		return ResponseEntity.status(HttpStatus.OK).body(selectedDataRulesList);
	}

	/**
	 * this method will delete the behavior pattern records corresponding to input
	 * behavior pattern ID
	 * 
	 * @param - Behavior Pattern ID
	 */
	@DeleteMapping(value = "/deletebehaviorpattern/{behaviorpatternid}")
	public ResponseEntity deleteBehaviorPatternById(
			@PathVariable(name = "behaviorpatternid") Integer behaviorPatternId)

	{
		List<String> deleteBehaviorPatternMessages;
		try {
			deleteBehaviorPatternMessages = iBehaviorPatternDataService.deleteBehaviorPattern(behaviorPatternId);
		} catch (BehaviorPatternApiException ex) {
			logit.error(BehaviorPatternConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(BehaviorPatternConstants.EXCEPTION_MESSAGE);
		}
		return ResponseEntity.status(HttpStatus.OK).body(deleteBehaviorPatternMessages);
	}

	/**
	 * this method will add a behavior pattern
	 * 
	 * @param - behaviorPatternDTO
	 */
	@PostMapping(value = { "/newbehaviorpattern" })
	public ResponseEntity newBehaviorPattern(@RequestBody BehaviorPatternDTO behaviorPatternDTO) {
		BehaviorPatternDTO retBehaviorPatternDTO = null;
		String userAccess = "";
		boolean userHasAccess = false;
		try {
			DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(BehaviorPatternConstants.DATE_FORMAT_MMDDYYYY_HHMMSS_A,
					Locale.ENGLISH);
			AppUser user = (AppUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
			behaviorPatternDTO.setCreatedBySystemId(user.getUserSystemId());
			behaviorPatternDTO.setModifiedBySystemId(user.getUserSystemId());
			List<AccessLevel> userAccessLevels = user.getRole().getAllowedAccesses();
			for (AccessLevel userAccessLevel : userAccessLevels) {
				if (userAccessLevel.getModuleCode().equals("STUDY")) {
					userAccess = userAccessLevel.getAccess();
					break;
				}
			}
			if (userAccess.equals("A") || userAccess.equals("B")) {
				userHasAccess = true;
			}
			if (userHasAccess) {
				LocalDateTime currentLocalDate = LocalDateTime.now(iBehaviorPatternDataService.getZoneId());
				// Save the create, update date as per local time zone in the DTO
				behaviorPatternDTO.setCreatedDate(dateTimeFormatter.format(currentLocalDate));
				behaviorPatternDTO.setModifiedDate(dateTimeFormatter.format(currentLocalDate));
				retBehaviorPatternDTO = iBehaviorPatternDataService.addBehaviorPattern(behaviorPatternDTO);
				return ResponseEntity.status(HttpStatus.CREATED).body(retBehaviorPatternDTO);
			} else {
				return new ResponseEntity<String>(BehaviorPatternConstants.NOT_AUTHORIZED, HttpStatus.FORBIDDEN);
			}	
		} catch (BehaviorPatternApiException ex) {
			logit.error(BehaviorPatternConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(BehaviorPatternConstants.EXCEPTION_MESSAGE);
		}
		
	}

	/**
	 * this method will update a behavior pattern
	 * 
	 * @param - behaviorPatternDTO
	 */
	@PutMapping(value = { "/updatebehaviorpattern/{erId}" })
	public ResponseEntity<String> updateBehaviorPattern(@PathVariable(name = "erId") Integer erId,
			@RequestBody BehaviorPatternDTO behaviorPatternDTO) {
		String updBehaviorPatternMessage;
		String userAccess = "";
		boolean userHasAccess = false;
		try {
			DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(BehaviorPatternConstants.DATE_FORMAT_MMDDYYYY_HHMMSS_A,
					Locale.ENGLISH);
			AppUser user = (AppUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
			behaviorPatternDTO.setModifiedBySystemId(user.getUserSystemId());
			List<AccessLevel> userAccessLevels = user.getRole().getAllowedAccesses();
			for (AccessLevel userAccessLevel : userAccessLevels) {
				if (userAccessLevel.getModuleCode().equals("STUDY")) {
					userAccess = userAccessLevel.getAccess();
					break;
				}
			}
			if (userAccess.equals("A") || 
					(userAccess.equals("B") && behaviorPatternDTO.getCreatedBySystemId().equals(user.getUserSystemId()))) {
				userHasAccess = true;
			}
			if (userHasAccess) {
				LocalDateTime currentLocalDate = LocalDateTime.now(iBehaviorPatternDataService.getZoneId());
				// Save the update date as per local time zone in the DTO
				behaviorPatternDTO.setModifiedDate(dateTimeFormatter.format(currentLocalDate));
				updBehaviorPatternMessage = iBehaviorPatternDataService.updateBehaviorPattern(erId, behaviorPatternDTO);
				return ResponseEntity.status(HttpStatus.OK).body(updBehaviorPatternMessage);
			} else {
				return ResponseEntity.status(HttpStatus.FORBIDDEN).body(BehaviorPatternConstants.NOT_AUTHORIZED);
			}
		} catch (BehaviorPatternApiException ex) {
			logit.error(BehaviorPatternConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(BehaviorPatternConstants.EXCEPTION_MESSAGE);
		}
		
	}
	/**
	 * this method will give all the Behavior Pattern data or records per page for My Items request
	 * 
	 * @param - ListTableParams (contains sort, filter conditions; page number, page
	 *          size)
	 */
	@GetMapping(value = { "/getmybehaviorpatterns/" }, headers = "Accept=application/json")
	public ResponseEntity getMyBehaviorPatterns(ListTableParams listTableParams) {
		PaginationResult paginationResult;
		try {
			Authentication auth =  SecurityContextHolder.getContext().getAuthentication();
			if (auth != null) {
				AppUser user = (AppUser) auth.getPrincipal();
				if (listTableParams.getSearchBy() == null) {
					listTableParams.setSearchBy(new ArrayList <String>());
					listTableParams.setSearchInput(new ArrayList <String>());
				}
				listTableParams.getSearchBy().add(BehaviorPatternConstants.USER_SYSTEM_ID);
				listTableParams.getSearchInput().add(user.getUserSystemId());
			}
			paginationResult = iBehaviorPatternDataService.getBehaviorPatternsList(listTableParams);
		} catch (BehaviorPatternApiException  ex) {
			logit.error(BehaviorPatternConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(BehaviorPatternConstants.EXCEPTION_MESSAGE);
		}
		return ResponseEntity.status(HttpStatus.OK).body(paginationResult);
	}
}



below is my UserDetailsService

package com.optum.fads.pgp.behavior.api.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.optum.fads.pgp.behavior.api.domain.SeSurGrpModAccess;
import com.optum.fads.pgp.behavior.api.domain.UiUserBase;
import com.optum.fads.pgp.behavior.api.dto.AccessLevel;
import com.optum.fads.pgp.behavior.api.dto.AppUser;
import com.optum.fads.pgp.behavior.api.dto.ModuleAccess;
import com.optum.fads.pgp.behavior.api.dto.Role;
import com.optum.fads.pgp.behavior.api.repo.UserRepository;
import com.optum.fads.pgp.behavior.api.service.IUserDetailsService;

@Service
public class UserDetailsService implements IUserDetailsService {

	@Autowired
	UserRepository userRepository;

	@Override
	@Transactional(readOnly = true)
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		Optional<UiUserBase> optional = userRepository.findByUiEMailAddress(username);
		optional.orElseThrow(() -> new UsernameNotFoundException("Not found: " + username));
		AppUser user = new AppUser();
		UiUserBase uiUserBase = optional.get();

		user.setUserEmail(uiUserBase.getUiEMailAddress());
		user.setUserId(uiUserBase.getUiUserId());
		user.setUserSystemId(uiUserBase.getUiSystemId());
		Role role = new Role();
		role.setId(Long.valueOf(uiUserBase.getSeUsrGrp().getSeSurGrp().getSurGrpId()).toString());
		role.setRoleName(uiUserBase.getSeUsrGrp().getSeSurGrp().getSurGrpName());
		List<SeSurGrpModAccess> surAccesses = uiUserBase.getSeUsrGrp().getSeSurGrp().getSeSurGrpModAccesses();

		List<AccessLevel> accesses = new ArrayList<AccessLevel>();
		surAccesses.forEach(surModuleAccess -> {
			accesses.add(new AccessLevel(surModuleAccess.getId().getSurModuleId(),
					ModuleAccess.getByName(surModuleAccess.getId().getSurModuleId()).toString(),
					surModuleAccess.getSeSurModule().getSurModuleName(),
					surModuleAccess.getSeSurAccess().getSurAccessId()));

		});

		role.setAllowedAccesses(accesses);
		user.setRole(role);
		return user;

	}

	

}
another class
package com.optum.fads.pgp.behavior.api.config;

import java.util.Collection;
import java.util.Collections;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;

import com.optum.fads.pgp.behavior.api.service.IUserDetailsService;




@SuppressWarnings("unused")
public class UserJwtAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {

	private static final String GROUPS_CLAIM = "groups";
	private static final String ROLE_PREFIX = "ROLE_";

	private final IUserDetailsService userDetailsService;

	public UserJwtAuthenticationConverter(IUserDetailsService userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	@Override
	public AbstractAuthenticationToken convert(Jwt jwt) {
		Collection<GrantedAuthority> authorities = extractAuthorities(jwt);
		return Optional.ofNullable(userDetailsService.loadUserByUsername(getUniqueID(jwt)))
				.map(u -> new UsernamePasswordAuthenticationToken(u, "n/a", authorities))
				.orElseThrow(() -> new BadCredentialsException("No user found"));
	}

	private Collection<GrantedAuthority> extractAuthorities(Jwt jwt) {
		return this.getGroups(jwt).stream().map(authority -> ROLE_PREFIX + authority.toUpperCase())
				.map(SimpleGrantedAuthority::new).collect(Collectors.toList());
	}

	@SuppressWarnings("unchecked")
	private Collection<String> getGroups(Jwt jwt) {
		Object groups = jwt.getClaims().get(GROUPS_CLAIM);
		if (groups instanceof Collection) {
			return (Collection<String>) groups;
		}

		return Collections.emptyList();
	}
    /*
	private String getUniqueID(Jwt jwt) {

		if(jwt.getClaimAsString("email") != null ) {
			return jwt.getClaimAsString("email");
		}
		if(jwt.getClaimAsString("preferred_username") != null ) {
			return jwt.getClaimAsString("preferred_username");
		}
        if(jwt.getClaimAsString("upn") != null ) {
			return jwt.getClaimAsString("upn");
		}
		
		return null;
	}*/
    private String getUniqueID(Jwt jwt) {


        return Stream.of("upn", "unique_name", "email", "sub")
                .map(jwt::getClaimAsString)
                .filter(v -> v != null && !v.isBlank())
                .findFirst()
                .orElse(null);
    }
	
}



below is my securityconfig
package com.optum.fads.pgp.behavior.api.config;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import com.optum.fads.pgp.behavior.api.service.IUserDetailsService;


import com.nimbusds.jwt.JWT;
import com.nimbusds.jwt.JWTParser;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final IUserDetailsService userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);

    public SecurityConfig(IUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

    	http.csrf(csrf -> csrf
    	        .ignoringRequestMatchers("/actuator/**", "/api/**")
    	)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth.requestMatchers("/actuator/**").permitAll()
                        .anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt
                                .decoder(jwtDecoder())
                                .jwtAuthenticationConverter(userJwtAuthenticationConverter())
                        )
                );

        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        // Custom JWT decoder that skips signature validation
        return token -> {
            try {
                JWT jwt = JWTParser.parse(token);

                // Convert claims, handling Date to Instant conversion
                Map<String, Object> claims = new HashMap<>(jwt.getJWTClaimsSet().getClaims());

                convertDateToInstant(claims, "iat");  // issued at
                convertDateToInstant(claims, "exp");  // expires at
                convertDateToInstant(claims, "nbf");  // not before
                convertDateToInstant(claims, "auth_time");  // authentication time

                return Jwt.withTokenValue(token)
                        .headers(headers -> headers.putAll(jwt.getHeader().toJSONObject()))
                        .claims(claimsMap -> claimsMap.putAll(claims))
                        .build();
            } catch (Exception e) {
                throw new JwtException("Failed to parse JWT", e);
            }
        };
    }

    private void convertDateToInstant(Map<String, Object> claims, String claimName) {
        Object value = claims.get(claimName);
        if (value instanceof Date) {
            claims.put(claimName, ((Date) value).toInstant());
        }
    }

    @Bean
    UserJwtAuthenticationConverter userJwtAuthenticationConverter() {
        logger.debug("Creating UserJwtAuthenticationConverter bean");
        return new UserJwtAuthenticationConverter(userDetailsService);
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        logger.debug("Creating PasswordEncoder bean using DelegatingPasswordEncoder");
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        logger.debug("Creating CorsConfigurationSource bean");
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Collections.singletonList(CorsConfiguration.ALL));
        configuration.setAllowedMethods(Collections.singletonList(CorsConfiguration.ALL));
        configuration.setAllowedHeaders(Collections.singletonList(CorsConfiguration.ALL));
        //	configuration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        logger.info("CORS configuration registered for all paths");
        return source;
    }
}



package com.optum.fads.pgp.behavior.api.config;

import javax.sql.DataSource;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = "com.optum.fads.pgp.behavior.api")
@ComponentScan(basePackages = { "com.optum.fads.pgp.behavior.api" })
public class ServiceConfig 
{
	@Bean(name = "fadsDataSource")
	@ConfigurationProperties("spring.datasource")
	public DataSource customDataSource() {
		return DataSourceBuilder.create().build();
	}

}



/*
//***********************************************
// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/

package com.optum.fads.pgp.behavior.api.config;

import static org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE;

import java.util.TimeZone;

import jakarta.annotation.PostConstruct;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;
import org.springframework.web.client.RestTemplate;

/**
 * The CommonConfig holds spring based configuration
 */
@Configuration
public class CommonConfig {

    /**
     * Model Mapper for mapping objects
     *
     * @return modelMapper
     */
    @Bean
    @Scope(SCOPE_PROTOTYPE)
    public ModelMapper modelMapper() {
        final var modelMapper = new ModelMapper();
        modelMapper.getConfiguration().setAmbiguityIgnored(true);
        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
        return modelMapper;
    }
    @Bean
	public RestTemplate restTemplate() {
	    return new RestTemplate();
	}
    
    @PostConstruct
    void started() {
      TimeZone.setDefault(TimeZone.getTimeZone("UTC-4"));
    }
    
}
http://localhost:8080/behavior/getbehaviorpatterns/

this url is post I am hitting getting 401 with token but no logs can u help to generate the logs in some location and fix this security config also 
