
2025-09-03 14:44:50 [http-nio-8080-exec-10] DEBUG o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - Resolved [org.springframework.web.bind.MethodArgumentNotValidException: Validation failed for argument [0] in public org.springframework.http.ResponseEntity com.optum.fads.pgp.study.controller.StudyController.createStudy(com.optum.fads.pgp.datarules.dto.StudyDTO) with 2 errors: [Field error in object 'studyDTO' on field 'xoverClaim': rejected value [null]; codes [NotNull.studyDTO.xoverClaim,NotNull.xoverClaim,NotNull.java.lang.Integer,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [studyDTO.xoverClaim,xoverClaim]; arguments []; default message [xoverClaim]]; default message [Cross Over value should be 0,1 or 2 ]] [Field error in object 'studyDTO' on field 'ffsClaim': rejected value [null]; codes [NotNull.studyDTO.ffsClaim,NotNull.ffsClaim,NotNull.java.lang.Integer,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [studyDTO.ffsClaim,ffsClaim]; arguments []; default message [ffsClaim]]; default message [Fee for Service is required!!]] ]
2025-09-03 14:44:50 [http-nio-8080-exec-10] DEBUG o.s.o.j.s.OpenEntityManagerInViewInterceptor - Closing JPA EntityManager in OpenEntityManagerInViewInterceptor
2025-09-03 14:44:50 [http-nio-8080-exec-10] DEBUG o.s.web.servlet.DispatcherServlet - Completed 400 BAD_REQUEST
2025-09-03 14:44:50 [http-nio-8080-exec-1] DEBUG o.s.security.web.FilterChainProxy - Securing GET /study/study/undefined

package com.optum.fads.pgp.datarules.domain;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.NoArgsConstructor;

import org.hibernate.annotations.Formula;

import jakarta.persistence.*;
import com.optum.fads.authorization.api.domain.UiUserBase;

/**
 * The persistent class for the PRM_STUDY_MASTER_T database table.
 * 
 */

@Entity
@Builder
@Table(name = "PRM_STUDY_MASTER_T")
@AllArgsConstructor
@NoArgsConstructor
public class PrmStudyMasterT implements Serializable {
	private static final long serialVersionUID = 1L;

	@Id
	@Column(name = "PB_ID", unique = true, nullable = false, precision = 7)
	private Integer pbId;

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "CREATE_DTE")
	private Date  createDte;

	@Column(name = "ENC_FFS", nullable = false, precision = 1)
	private Integer encFfs;

	@Column(name = "PB_DESC", length = 255)
	private String pbDesc;

	@Column(name = "PB_EXCP_ONLY_FLAG", nullable = false, precision = 1)
	private Integer pbExcpOnlyFlag;

	@Column(name = "PB_FP_FLAG", precision = 1)
	private Integer pbFpFlag;

	@Column(name = "PB_NAME", nullable = false, length = 50)
	private String pbName;

	@Column(name = "PB_USE_DW_FLAG", nullable = false, precision = 1)
	private Integer pbUseDwFlag;

	@Column(name = "PB_USE_VW_FLAG", nullable = false, precision = 1)
	private Integer pbUseVwFlag;

	@Column(name = "SUBMIT_FLAG", precision = 1)
	private Integer submitFlag;

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "UPDATE_DTE")
	private Date  updateDte;

	@Column(nullable = false, precision = 1)
	private Integer xovers;

	// bi-directional many-to-one association to PrmPgPeerGroupT
	@ManyToOne
	@JoinColumn(name = "CG_ID", nullable = false)
	private PrmPgPeerGroupT prmPgPeerGroupT;

	// bi-directional many-to-one association to UiUserBase
	@ManyToOne
	@JoinColumn(name = "UI_USER_ID")
	private UiUserBase uiUserBase;

	// bi-directional many-to-one association to UiUserBase
	@ManyToOne
	@JoinColumn(name = "CREATE_USR", nullable = false)
	private UiUserBase createdByUiUserBase;

	// bi-directional many-to-one association to UiUserBase
	@ManyToOne
	@JoinColumn(name = "UPDATE_USR", nullable = false)
	private UiUserBase updatedByUiUserBase;

	public List<PrmStudyBpActLimitsT> getPrmStudyBpActLimitsTs() {
		return prmStudyBpActLimitsTs;
	}

	public void setPrmStudyBpActLimitsTs(List<PrmStudyBpActLimitsT> prmStudyBpActLimitsTs) {
		this.prmStudyBpActLimitsTs = prmStudyBpActLimitsTs;
	}

	public List<PrmStudyRsRiExceptT> getPrmStudyRsRiExceptTs() {
		return prmStudyRsRiExceptTs;
	}

	public void setPrmStudyRsRiExceptTs(List<PrmStudyRsRiExceptT> prmStudyRsRiExceptTs) {
		this.prmStudyRsRiExceptTs = prmStudyRsRiExceptTs;
	}

	public List<PrmStudyRsRiT> getPrmStudyRsRiTs() {
		return prmStudyRsRiTs;
	}

	public void setPrmStudyRsRiTs(List<PrmStudyRsRiT> prmStudyRsRiTs) {
		this.prmStudyRsRiTs = prmStudyRsRiTs;
	}

	public List<PrmStudyTimePeriodsT> getPrmStudyTimePeriodsTs() {
		return prmStudyTimePeriodsTs;
	}

	public void setPrmStudyTimePeriodsTs(List<PrmStudyTimePeriodsT> prmStudyTimePeriodsTs) {
		this.prmStudyTimePeriodsTs = prmStudyTimePeriodsTs;
	}

	public LocalDateTime getLastRunDate() {
		return lastRunDate;
	}

	public void setLastRunDate(LocalDateTime lastRunDate) {
		this.lastRunDate = lastRunDate;
	}

	public LocalDateTime getScheduleRunDateTime() {
		return scheduleRunDateTime;
	}

	public void setScheduleRunDateTime(LocalDateTime scheduleRunDateTime) {
		this.scheduleRunDateTime = scheduleRunDateTime;
	}

	@OneToMany(mappedBy = "prmStudyMasterT",  cascade = CascadeType.ALL, orphanRemoval = true)
	private List<PrmStudyBpActLimitsT> prmStudyBpActLimitsTs;

	@OneToMany(mappedBy = "prmStudyMasterT", cascade = CascadeType.ALL, orphanRemoval = true)
	private List<PrmStudyRsRiExceptT> prmStudyRsRiExceptTs = new ArrayList<PrmStudyRsRiExceptT>();

	@OneToMany(mappedBy = "prmStudyMasterT", cascade = CascadeType.ALL, orphanRemoval = true)
	private List<PrmStudyRsRiT> prmStudyRsRiTs = new ArrayList<PrmStudyRsRiT>();;

	@OneToMany(mappedBy = "prmStudyMasterT", cascade = CascadeType.ALL, orphanRemoval = true)
	private List<PrmStudyTimePeriodsT> prmStudyTimePeriodsTs = new ArrayList<PrmStudyTimePeriodsT>();


	@Formula("(select max(j.date_End) from job_Master_T j where j.pb_Id = pb_Id)")
	private LocalDateTime lastRunDate;

	@Formula("(select max(j.date_sched) from job_Master_T j where j.pb_Id = pb_Id)")
	private LocalDateTime scheduleRunDateTime;

	public Integer getPbId() {
		return pbId;
	}

	public void setPbId(Integer pbId) {
		this.pbId = pbId;
	}

	public Date getCreateDte() {
		return createDte;
	}

	public void setCreateDte(Date createDte) {
		this.createDte = createDte;
	}

	public Integer getEncFfs() {
		return encFfs;
	}

	public void setEncFfs(Integer encFfs) {
		this.encFfs = encFfs;
	}

	public String getPbDesc() {
		return pbDesc;
	}

	public void setPbDesc(String pbDesc) {
		this.pbDesc = pbDesc;
	}

	public Integer getPbExcpOnlyFlag() {
		return pbExcpOnlyFlag;
	}

	public void setPbExcpOnlyFlag(Integer pbExcpOnlyFlag) {
		this.pbExcpOnlyFlag = pbExcpOnlyFlag;
	}

	public Integer getPbFpFlag() {
		return pbFpFlag;
	}

	public void setPbFpFlag(Integer pbFpFlag) {
		this.pbFpFlag = pbFpFlag;
	}

	public String getPbName() {
		return pbName;
	}

	public void setPbName(String pbName) {
		this.pbName = pbName;
	}

	public Integer getPbUseDwFlag() {
		return pbUseDwFlag;
	}

	public void setPbUseDwFlag(Integer pbUseDwFlag) {
		this.pbUseDwFlag = pbUseDwFlag;
	}

	public Integer getPbUseVwFlag() {
		return pbUseVwFlag;
	}

	public void setPbUseVwFlag(Integer pbUseVwFlag) {
		this.pbUseVwFlag = pbUseVwFlag;
	}

	public Integer getSubmitFlag() {
		return submitFlag;
	}

	public void setSubmitFlag(Integer submitFlag) {
		this.submitFlag = submitFlag;
	}

	public Date getUpdateDte() {
		return updateDte;
	}

	public void setUpdateDte(Date updateDte) {
		this.updateDte = updateDte;
	}

	public Integer getXovers() {
		return xovers;
	}

	public void setXovers(Integer xovers) {
		this.xovers = xovers;
	}

	public PrmPgPeerGroupT getPrmPgPeerGroupT() {
		return prmPgPeerGroupT;
	}

	public void setPrmPgPeerGroupT(PrmPgPeerGroupT prmPgPeerGroupT) {
		this.prmPgPeerGroupT = prmPgPeerGroupT;
	}

	public UiUserBase getUiUserBase() {
		return uiUserBase;
	}

	public void setUiUserBase(UiUserBase uiUserBase) {
		this.uiUserBase = uiUserBase;
	}

	public UiUserBase getCreatedByUiUserBase() {
		return createdByUiUserBase;
	}

	public void setCreatedByUiUserBase(UiUserBase createdByUiUserBase) {
		this.createdByUiUserBase = createdByUiUserBase;
	}

	public UiUserBase getUpdatedByUiUserBase() {
		return updatedByUiUserBase;
	}

	public void setUpdatedByUiUserBase(UiUserBase updatedByUiUserBase) {
		this.updatedByUiUserBase = updatedByUiUserBase;
	}

}


/**
 * @author sbiry
 *
 */
package com.optum.fads.pgp.study.mapper;

import java.util.List;

import org.mapstruct.InheritInverseConfiguration;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;
import org.mapstruct.ReportingPolicy;
import org.mapstruct.factory.Mappers;

import com.optum.fads.pgp.datarules.domain.PrmDrDataRuleT;
import com.optum.fads.pgp.datarules.domain.PrmPgPeerGroupT;
import com.optum.fads.pgp.datarules.domain.PrmRsRiT;
import com.optum.fads.pgp.datarules.domain.PrmRsRptSecT;
import com.optum.fads.pgp.datarules.domain.PrmStudyBpActLimitsT;
import com.optum.fads.pgp.datarules.domain.PrmStudyMasterT;
import com.optum.fads.pgp.datarules.domain.PrmStudyRsRiExceptT;
import com.optum.fads.pgp.datarules.domain.PrmStudyRsRiT;
import com.optum.fads.pgp.datarules.domain.PrmStudyTimePeriodsT;
import com.optum.fads.pgp.datarules.dto.ActivityLimit;
import com.optum.fads.pgp.datarules.dto.DataRule;
import com.optum.fads.pgp.datarules.dto.PeerGroup;
import com.optum.fads.pgp.datarules.dto.ReportItem;
import com.optum.fads.pgp.datarules.dto.ReportSection;
import com.optum.fads.pgp.datarules.dto.StudyDTO;
import com.optum.fads.pgp.datarules.dto.StudyRsRiException;
import com.optum.fads.pgp.datarules.dto.StudyRsRiItem;
import com.optum.fads.pgp.datarules.dto.TimePeriod;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface StudyDetailMapper {
	StudyMiniMapper INSTANCE = Mappers.getMapper(StudyMiniMapper.class);

	@Mappings({ @Mapping(source = "pbId", target = "studyId"), 
			@Mapping(source = "pbName", target = "studyName"),
			@Mapping(source = "pbDesc", target = "description"), 
			@Mapping(source = "encFfs", target = "ffsClaim"),
			@Mapping(source = "xovers", target = "xoverClaim"),
			@Mapping(source = "pbExcpOnlyFlag", target = "pbExcpOnlyFlag"),
			@Mapping(source = "pbFpFlag", target = "pbFpFlag"),
			@Mapping(source = "pbUseDwFlag", target = "pbUseDwFlag"),
			@Mapping(source = "pbUseVwFlag", target = "pbUseVwFlag"),
			@Mapping(source = "submitFlag", target = "submitFlag"),
			@Mapping(source = "uiUserBase.uiSystemId", target = "user"),
			@Mapping(source = "createdByUiUserBase.uiSystemId", target = "createdBySystemId"),
			@Mapping(source = "updatedByUiUserBase.uiSystemId", target = "updatedBySystemId"),
			@Mapping(target = "createdUser", source = "createdByUiUserBase.userFullName"),
			@Mapping(target = "updatedUser", source = "updatedByUiUserBase.userFullName"),
			@Mapping(source = "prmPgPeerGroupT", target = "peerGroup"),
			@Mapping(source = "prmStudyTimePeriodsTs", target = "timePeriods"),
			@Mapping(source = "prmStudyBpActLimitsTs", target = "activityLimits"),
			@Mapping(source = "createDte", target = "createDate"),
			@Mapping(source = "updateDte", target = "updateDate"),
			@Mapping(source = "lastRunDate", target = "lastRunDate"),
			@Mapping(source = "prmStudyRsRiTs", target = "reportSections") })
	public StudyDTO toStudyDTO(PrmStudyMasterT prmStudyMasterT);

	@Mappings({ @Mapping(target = "studyGroupId", source = "cgId"),
			@Mapping(target = "studyGroupName", source = "studyGroupName"), @Mapping(target = "type", source = "cgType"),
			@Mapping(target = "dataRules", source = "prmDrDataRuleTs") })
	public PeerGroup toStudyPeerGroup(PrmPgPeerGroupT prmPgPeerGroupT);

	@Mappings({ @Mapping(target = "dataRuleId", source = "drId"),
			@Mapping(target = "dataRuleName", source = "dataRuleName") })
	public DataRule toDayaTule(PrmDrDataRuleT prmDrDataRuleT);

	@Mappings({ @Mapping(target = "timePeriodId", source = "id.pbTimePrd"),
			@Mapping(target = "fromDate", source = "pbTimeRngBeg"),
			@Mapping(target = "toDate", source = "pbTimeRngEnd"),
			@Mapping(target = "weight", source = "pbTimeWeight"),
			@Mapping(target = "createdUser", source = "uiUserBase2.uiSystemId"),
			@Mapping(target = "updatedUser", source = "updatedByUiUserBase.uiSystemId"),
		
	})
	public TimePeriod toStudyTimePeriod(PrmStudyTimePeriodsT prmStudyTimePeriodsT);

	@Mappings({ @Mapping(target = "reportSectionId", source = "id.rsId"),
			@Mapping(target = "reportSectionName", source = "prmRsRptSecT.reportSectionName"),
			@Mapping(target = "reportItems", source = "prmRsRptSecT.prmRsRiTs"),
			
			@Mapping(target = "modifiedBy", source = "prmRsRptSecT.uiUserBaseUpd.userFullName"),
			//@Mapping(target = "modifiedDate",  source= "prmRsRptSecT.updateDte")
	})
	public ReportSection toStudyReportSection(PrmStudyRsRiT prmStudyRsRiT);

	@Mappings({ @Mapping(target = "reportSectionId", source = "id.rsId"),
			@Mapping(target = "reportItemId", source = "id.riId"),
			@Mapping(target = "rsOrder", source = "id.rsOrder"),
			@Mapping(target = "lowerLimit", source = "pbRiOlLolmt"),
			@Mapping(target = "standardDeviation", source = "pbRiOlSdev"),
			@Mapping(target = "upperLimit", source = "pbRiOlUplmt"),
			@Mapping(target = "percentage", source = "pbRiOlPct") ,
			@Mapping(target = "weight", source = "pbRiWeight") ,
	})
	public StudyRsRiItem toStudyRsRiItem(PrmStudyRsRiT prmStudyRsRiT);

	@Mappings({ @Mapping(target = "reportSectionId", source = "id.rsId"),
			@Mapping(target = "reportItemId", source = "id.riId"),
			@Mapping(target = "timePeriodId", source = "id.pbTimePrd"),
			@Mapping(target = "exceptionFlag", source = "pbriExcpFlag"),
			@Mapping(target = "overLimitFlag", source = "pbriOverLmtFlag") })
	public StudyRsRiException toStudyRsRiException(PrmStudyRsRiExceptT prmStudyRsRiExceptT);

	@Mappings({ @Mapping(target = "reportItemId", source = "id.riId"),
				@Mapping(target = "order", source = "riOrder") ,
				@Mapping(target = "reportItemName", source = "prmRiRptItemT.reportItemName")
	})
	public ReportItem toReportItem(PrmRsRiT prmRsRiT);

	@Mappings({ @Mapping(source = "id.bpId", target = "behaviorPatternId"),
			@Mapping(source = "prmBpBehaviorPatsT.behaviorPatternName", target = "behaviorPatternName"),
			@Mapping(source = "vcMin", target = "min"), @Mapping(source = "vcMax", target = "max"),
			@Mapping(source = "vcFlag", target = "flag") })
	public ActivityLimit toActivityLimit(PrmStudyBpActLimitsT prmStudyBpActLimitsT);

	public List<TimePeriod> toTimePeriods(List<PrmStudyTimePeriodsT> prmStudyTimePeriodsTs);

	public List<ReportSection> toReportSections(List<PrmRsRptSecT> prmStudyRsRiTs);

	public List<ReportItem> toReportItems(List<PrmStudyRsRiT> prmStudyRsRiTs);

	public List<StudyRsRiItem> toStudyRsRiItems(List<PrmStudyRsRiT> prmStudyRsRiTs);

	public List<StudyRsRiException> toStudyRsRiExceptions(List<PrmStudyRsRiExceptT> prmStudyRsRiExceptTs);

	// From Dto to Entity

	@InheritInverseConfiguration
	@Mappings({ 
			@Mapping(source = "peerGroup", target = "prmPgPeerGroupT"),
			@Mapping(source = "timePeriods", target = "prmStudyTimePeriodsTs"),
			@Mapping(source = "activityLimits", target = "prmStudyBpActLimitsTs"),
			@Mapping(source = "reportSections", target = "prmStudyRsRiTs") })
	PrmStudyMasterT convertToPrmStudyMasterT(StudyDTO studyDTO);
	
	@InheritInverseConfiguration
	@Mappings({ 
			@Mapping(source = "timePeriodId", target = "id.pbTimePrd"),
			@Mapping(source = "fromDate", target = "pbTimeRngBeg"),
			@Mapping(source = "toDate", target = "pbTimeRngEnd"),
			@Mapping(source = "weight", target = "pbTimeWeight"),
	})
	public PrmStudyTimePeriodsT toPrmStudyTimePeriodsT(TimePeriod timePeriod);

	@InheritInverseConfiguration
	@Mappings({ @Mapping(target = "id.bpId", source = "behaviorPatternId"), @Mapping(target = "vcMin", source = "min"),
			@Mapping(target = "vcMax", source = "max"), @Mapping(target = "vcFlag", source = "flag") })
	public PrmStudyBpActLimitsT toPrmStudyBpActLimitsT(ActivityLimit activityLimit);

	@InheritInverseConfiguration
	PrmPgPeerGroupT convertToEntity(PeerGroup studyDTO);

	@InheritInverseConfiguration
	public List<PrmStudyBpActLimitsT> toPrmStudyBpActLimitsTs(List<ActivityLimit> activityLimit);

	@InheritInverseConfiguration
	public List<PrmStudyTimePeriodsT> toPrmStudyTimePeriodsTs(List<TimePeriod> timePeriods);

	@InheritInverseConfiguration
	public List<PrmRsRptSecT> toPrmRsRptSecTs(List<ReportSection> reportSections);

	@InheritInverseConfiguration
	public List<PrmStudyRsRiT> toPrmStudyRsRiTs(List<ReportSection> reportSections);

}


/**
 * 
 */
package com.optum.fads.pgp.datarules.dto;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

/**
 * @author sbiry
 *
 */
@Getter
@Setter
@Data
@ToString
@NoArgsConstructor
@JsonIgnoreProperties({ "pbFpFlag", "user", "pbExcpOnlyFlag" })
public class StudyDTO implements Serializable {
	private static final long serialVersionUID = 1L;

//	@NotNull
	private Integer studyId;

	@NotNull(message = "Study Name is required")
	@Size(min = 1, max = 50)
	private String studyName;

	private String description;

	@NotNull(message = "Fee for Service is required!!")
	@PositiveOrZero(message = "Fee for Service value should be 0,1 or 2 ")
	private Integer ffsClaim;

	@NotNull(message = "Cross Over value should be 0,1 or 2 ")
	@PositiveOrZero(message = "Cross Over value should be 0,1 or 2 ")
	private Integer xoverClaim;

	private Integer pbFpFlag = 1;
	private String user;
	private String createdUser;
	private String updatedUser;
	private String createdBySystemId;
	private String updatedBySystemId;

	@JsonFormat(pattern = "MM/dd/yyyy hh:mm a")
	@JsonSerialize(using = LocalDateTimeSerializer.class)
	@JsonDeserialize(using = LocalDateTimeDeserializer.class)
	private LocalDateTime createDate;

	@JsonFormat(pattern = "MM/dd/yyyy hh:mm a")
	@JsonSerialize(using = LocalDateTimeSerializer.class)
	@JsonDeserialize(using = LocalDateTimeDeserializer.class)
	private LocalDateTime updateDate;

	@NotNull(message = "please enter atleaast one time period ")
	@NotEmpty(message = "please enter atleaast one time period ")
	@StudyValid
	private List<@NotNull @Valid TimePeriod> timePeriods;

	@NotNull(message = "Peergroup is a required ")
	@Valid
	private PeerGroup peerGroup;

	@NotNull(message = "please enter atleaast one report section")
	@NotEmpty(message = "please enter atleaast one report section")
	private Set<@NotNull @Valid ReportSection> reportSections;

	private Set<ActivityLimit> activityLimits;
	private int pbExcpOnlyFlag = 0;
	private int pbUseDwFlag = 1;
	private int pbUseVwFlag = 1;
	private int submitFlag = 1;

	@JsonFormat(pattern = "MM/dd/yyyy hh:mm a")
	@JsonSerialize(using = LocalDateTimeSerializer.class)
	@JsonDeserialize(using = LocalDateTimeDeserializer.class)
	private LocalDateTime lastRunDate;
}



	@PostMapping("study")
	public ResponseEntity createStudy(@Valid @RequestBody StudyDTO study) {
//		if (errors.hasErrors()) {
//	        return new ResponseEntity(new ApiErrors(errors), HttpStatus.BAD_REQUEST);
//	    }
		
		logit.info("Principal class: here check logit.infostudyOwnRepository.testing in controller begining   ");
		StudyDTO studyDto = null;
		String userAccess = "";
		boolean userHasAccess = false;
		AppUser user = (AppUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		List<AccessLevel> userAccessLevels = user.getRole().getAllowedAccesses();
		for (AccessLevel userAccessLevel : userAccessLevels) {
			if (userAccessLevel.getModuleCode().equals("STUDY")) {
				userAccess = userAccessLevel.getAccess();
				break;
			}
		}
		logit.info("Principal class: here check logit.infostudyOwnRepository.testing in controller start   ");
		if (userAccess.equals("A") || userAccess.equals("B")) {
			userHasAccess = true;
		}
		if (userHasAccess) {
			study.setCreatedBySystemId(user.getUserSystemId());
			study.setUpdatedBySystemId(user.getUserSystemId());
			study.setUser(user.getUserSystemId());
			study.getTimePeriods().forEach(tp -> {
				tp.setCreatedUser(user.getUserSystemId());
				tp.setUpdatedUser(user.getUserSystemId());
			});
			logit.info("Principal class: here check logit.infostudyOwnRepository.testing in controller efore  ");
			LocalDateTime currentLocalDate = LocalDateTime.now(commonService.getZoneId());
			study.setCreateDate(currentLocalDate);
			study.setUpdateDate(currentLocalDate);
			studyDto = studyService.createStudy(study);
			return new ResponseEntity<StudyDTO>(studyDto, HttpStatus.CREATED);
		} else {
			return new ResponseEntity<String>(StudyConstants.NOT_AUTHORIZED, HttpStatus.FORBIDDEN);
		}

	}


http://localhost:8080/fads/study/study

{
    "timestamp": [
        2025,
        9,
        3,
        14,
        44,
        50,
        232585400
    ],
    "status": 400,
    "errors": [
        "xoverClaim: Cross Over value should be 0,1 or 2 ",
        "ffsClaim: Fee for Service is required!!"
    ]
}
