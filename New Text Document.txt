CREATE TABLE INVOICE_FINAL (
  invoice_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  run_id VARCHAR(80),
  customer_id VARCHAR(20),
  invoice_date DATE,

  total_gross DECIMAL(18,2) DEFAULT 0,
  total_discount DECIMAL(18,2) DEFAULT 0,
  total_tax DECIMAL(18,2) DEFAULT 0,
  total_commission DECIMAL(18,2) DEFAULT 0,
  total_net DECIMAL(18,2) DEFAULT 0,

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


package com.optum.fads.caseentrybatch.poc.batch;

import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.PreparedStatementSetter;

/**
 * Reads aggregated invoice data from FINAL_TXN_LINE and produces
 * one row per (run_id, customer_id, invoice_date).
 *
 * IMPORTANT:
 * 1. We use COALESCE around SUM() so NULL values never propagate.
 * 2. This guarantees inserts into INVOICE_FINAL never fail due to NULL totals.
 * 3. This is the final stabilization layer of your batch pipeline.
 */
@Configuration
public class InvoiceAggregationConfig {

    @Bean
    @StepScope
    public JdbcCursorItemReader<InvoiceSummary> invoiceSummaryReader(
            DataSource dataSource,
            @Value("#{jobParameters['runId']}") String runId,
            @Value("#{jobParameters['invoiceDate']}") String invoiceDateStr
    ) {

        final String effectiveRunId = runId;
        final String effectiveInvoiceDate =
                (invoiceDateStr == null || invoiceDateStr.isBlank())
                        ? "2026-01-24"
                        : invoiceDateStr;

        String sql =
            "SELECT run_id AS runId, " +
            "       customer_id AS customerId, " +
            "       invoice_date AS invoiceDate, " +

            // ---- Use COALESCE to prevent NULL totals ----
            "       ROUND(COALESCE(SUM(base_amount),0),2)      AS totalGross, " +
            "       ROUND(COALESCE(SUM(discount),0),2)         AS totalDiscount, " +
            "       ROUND(COALESCE(SUM(tax),0),2)              AS totalTax, " +
            "       ROUND(COALESCE(SUM(commission),0),2)       AS totalCommission, " +
            "       ROUND(COALESCE(SUM(net_amount),0),2)       AS totalNet " +

            "FROM FINAL_TXN_LINE " +
            "WHERE run_id = ? AND invoice_date = ? " +
            "GROUP BY run_id, customer_id, invoice_date " +
            "ORDER BY customer_id";

        PreparedStatementSetter pss = new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                ps.setString(1, effectiveRunId);
                ps.setDate(2, Date.valueOf(effectiveInvoiceDate));
            }
        };

        return new JdbcCursorItemReaderBuilder<InvoiceSummary>()
                .name("invoiceSummaryReader")
                .dataSource(dataSource)
                .sql(sql)
                .preparedStatementSetter(pss)
                .rowMapper(new BeanPropertyRowMapper<>(InvoiceSummary.class))
                .build();
    }
}
