1) Use the correct Specification type everywhere
Make sure every file uses:
import org.springframework.data.jpa.domain.Specification;

and NOT anything from jakarta.persistence.criteria.Specification (there is no such type) or other packages.
Files to check:


UserService (method signature)


UserServiceImpl


UserSpecification (class return type)


Any other place you mention Specification



2) Repository must extend JpaSpecificationExecutor
package com.optum.fads.userroles.api.repo;

import com.optum.fads.userroles.api.domain.UiUserBase;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface UiUserBaseRepository
        extends JpaRepository<UiUserBase, String>,
                JpaSpecificationExecutor<UiUserBase> {  // <-- required
}

Double-check you have both imports above.

3) Make UserSpecification return the correct type
package com.optum.fads.userroles.api.spec;

import com.optum.fads.userroles.api.domain.UiUserBase;
import jakarta.persistence.criteria.*;            // for Root/From/Join etc.
import org.springframework.data.jpa.domain.Specification;  // <-- Spring Data type

import java.util.*;

public final class UserSpecification {

    private UserSpecification() {}

    public static Specification<UiUserBase> containsAll(
            Map<String, String> filters,
            Map<String, String> fieldMap
    ) {
        if (filters == null || filters.isEmpty()) {
            return null; // tells caller: no filtering
        }

        return (root, query, cb) -> {
            query.distinct(true);
            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, String> e : filters.entrySet()) {
                String apiField = e.getKey();
                String value    = e.getValue();
                if (value == null || value.isBlank()) continue;

                String entityPath = fieldMap.get(apiField);
                if (entityPath == null) continue;

                Expression<String> path = resolvePath(root, entityPath); // LEFT joins under the hood
                predicates.add(cb.like(cb.lower(path), "%" + value.toLowerCase(Locale.ROOT) + "%"));
            }

            return predicates.isEmpty() ? cb.conjunction() : cb.and(predicates.toArray(new Predicate[0]));
        };
    }

    @SuppressWarnings("unchecked")
    private static Expression<String> resolvePath(From<?, ?> root, String dotPath) {
        String[] parts = dotPath.split("\\.");
        From<?, ?> from = root;
        Path<?> path = root;

        for (int i = 0; i < parts.length; i++) {
            String part = parts[i];
            if (i < parts.length - 1) {
                from = safeJoin(from, part);
                path = from;
            } else {
                path = path.get(part);
            }
        }
        return (Expression<String>) path.as(String.class);
    }

    private static From<?, ?> safeJoin(From<?, ?> from, String attribute) {
        for (Join<?, ?> j : from.getJoins()) {
            if (j.getAttribute() != null && attribute.equals(j.getAttribute().getName())) {
                return (From<?, ?>) j;
            }
        }
        return from.join(attribute, JoinType.LEFT);
    }
}


4) Guard the service call when filters are empty
Some Spring Data versions have two findAll overloads (by example and by spec). To avoid ambiguity, only call the spec overload if we actually have a spec:
package com.optum.fads.userroles.api.service;

import com.optum.fads.userroles.api.domain.UiUserBase;
import com.optum.fads.userroles.api.dto.UserListItem;
import com.optum.fads.userroles.api.mapper.UserListItemMapper;
import com.optum.fads.userroles.api.repo.UiUserBaseRepository;
import com.optum.fads.userroles.api.spec.UserSpecification;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UiUserBaseRepository repo;
    private final UserListItemMapper mapper;

    @Override
    public Page<UserListItem> getUsers(Map<String, String> filters, Pageable pageable, Map<String, String> fieldMap) {
        Specification<UiUserBase> spec = UserSpecification.containsAll(filters, fieldMap);

        Page<UiUserBase> page = (spec == null)
                ? repo.findAll(pageable)                // no filters → use simple pageable
                : repo.findAll(spec, pageable);         // filters → use Specification overload

        return page.map(mapper::toDto);
    }
}


5) Clean build with the right Java level
You already set Java 17. Do a clean compile to ensure MapStruct and Spring Data codegen are fresh:
mvn -e -X clean compile -DskipTests

If the error persists, copy the exact text of the first error line (not just a photo). But in 90%+ of cases like your screenshot, it’s one of the import/overload issues above.

Quick checklist


 import org.springframework.data.jpa.domain.Specification; everywhere ✅


 Repository extends JpaSpecificationExecutor<UiUserBase> ✅


 UserSpecification.containsAll returns Specification<UiUserBase> ✅


 Service calls repo.findAll(pageable) when spec == null ✅


 mvn clean compile after changes ✅


Do these and the compile error should disappear.
