package com.optum.fads.userroles.api.repo;

import com.optum.fads.userroles.api.domain.UiUserBase;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface UiUserBaseRepository
        extends JpaRepository<UiUserBase, String>,
                JpaSpecificationExecutor<UiUserBase> {
}


package com.optum.fads.userroles.api.spec;

import com.optum.fads.userroles.api.domain.UiUserBase;
import jakarta.persistence.criteria.*;                         // Root/From/Join etc.
import org.springframework.data.jpa.domain.Specification;     // <-- Spring Data type

import java.util.*;

public final class UserSpecification {

    private UserSpecification() {}

    public static Specification<UiUserBase> containsAll(
            Map<String, String> filters,
            Map<String, String> fieldMap
    ) {
        if (filters == null || filters.isEmpty()) {
            return null;
        }

        return (root, query, cb) -> {
            query.distinct(true);
            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, String> e : filters.entrySet()) {
                String apiField = e.getKey();
                String value = e.getValue();
                if (value == null || value.isBlank()) continue;

                String entityPath = fieldMap.get(apiField);
                if (entityPath == null) continue;

                Expression<String> path = resolvePath(root, entityPath);
                predicates.add(cb.like(cb.lower(path), "%" + value.toLowerCase(Locale.ROOT) + "%"));
            }

            return predicates.isEmpty() ? cb.conjunction() : cb.and(predicates.toArray(new Predicate[0]));
        };
    }

    @SuppressWarnings("unchecked")
    private static Expression<String> resolvePath(From<?, ?> root, String dotPath) {
        String[] parts = dotPath.split("\\.");
        From<?, ?> from = root;
        Path<?> path = root;

        for (int i = 0; i < parts.length; i++) {
            String part = parts[i];
            if (i < parts.length - 1) {
                from = safeJoin(from, part);
                path = from;
            } else {
                path = path.get(part);
            }
        }
        return (Expression<String>) path.as(String.class);
    }

    private static From<?, ?> safeJoin(From<?, ?> from, String attribute) {
        for (Join<?, ?> j : from.getJoins()) {
            if (j.getAttribute() != null && attribute.equals(j.getAttribute().getName())) {
                return (From<?, ?>) j;
            }
        }
        return from.join(attribute, JoinType.LEFT);
    }
}
package com.optum.fads.userroles.api.service;

import com.optum.fads.userroles.api.dto.UserListItem;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.Map;

public interface UserService {
    Page<UserListItem> getUsers(Map<String, String> filters, Pageable pageable, Map<String, String> fieldMap);
}
package com.optum.fads.userroles.api.service;

import com.optum.fads.userroles.api.domain.UiUserBase;
import com.optum.fads.userroles.api.dto.UserListItem;
import com.optum.fads.userroles.api.mapper.UserListItemMapper;
import com.optum.fads.userroles.api.repo.UiUserBaseRepository;
import com.optum.fads.userroles.api.spec.UserSpecification;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;   // <-- Spring Data
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UiUserBaseRepository repo;
    private final UserListItemMapper mapper;

    @Override
    public Page<UserListItem> getUsers(Map<String, String> filters, Pageable pageable, Map<String, String> fieldMap) {
        Specification<UiUserBase> spec = UserSpecification.containsAll(filters, fieldMap);

        // Call the correct overload explicitly
        Page<UiUserBase> page = (spec == null)
                ? repo.findAll(pageable)             // no filters
                : repo.findAll(spec, pageable);      // with filters

        return page.map(mapper::toDto);
    }
}



import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
