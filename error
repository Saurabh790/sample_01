import React, { useState } from 'react';
import styled from 'styled-components';
import { Dialog, Label, TextInput, Button, OSGPListItemTemplateProps, Tag, OSGPList } from "@optum-osgp-temp/osgp-ui-component-lib";
import "../../../../pick-list/pick_list.scss"; 
import {  DataGrid } from '@optum-osgp-temp/osgp-ui-composite-comp-lib';
import RangeTable from '../../../../dataRule/RangeTable';
import { Switch } from '../../../../../common/components/Switch';
import { Description, Required } from '../../../../../common/StyledComponents';
import { urlConfig } from '../../../../../../../../utils/urlConfig';
import { Grid } from '@optum-osgp-internal/osgp-mui-component-lib/node_modules/@mui/material';
import { PGP_SUCCESS_MSG, PGP_USER_ACCESS } from '../../../../../constants';
import { store } from '@optum-osgp-temp/osgp-ui-state-management-lib';
import { PGP_USER_ROLE } from '../../../../../common/AppConstants';
import "../../../../../style.scss";
import { putData } from '../../../../../common/http-service';

const FormFieldContainer = styled.div`
	display: flex;
	> div {
		max-width: 250px;
		margin-right: 32px;
		input, button {
			width: 260px;
			height: 44px;
		}
	}
`;

const DataRuleSelectionWrapper = styled.div`
	margin-top: 16px;
`;

const RangeInfo = styled.p`
	margin: 24px 0;
	label{
		margin-right: 16px;
	}
`;

const SwitchContainer = styled.div`
	margin-top: 8px;
	margin-left: -8px;
`

const TagList = styled.div`
	flex: 1;
	margin-left: 8px;
	padding: 8px;
	h6{
		margin-top:-8px;
		margin-bottom: 8px;
	}
	.osgp-list  {
		border: 1px solid rgb(204, 204, 204);
		background: #fff;
		min-height: 385px;
		min-width: 150px
		overflow: auto;
	}
`;
const Wrapper = styled.div`
	nav{
		font-size: 1rem;
	},
	color: #333333 !important,
	border: "1px solid red"
`;
export default function EditDataRule(props: any) {
	const pgpUserAccess = store.get(PGP_USER_ROLE);
    const userData = store.get("userDetailData");
	const [dataElementSelection, setDataElementSelection] = useState<any>();
	const initialRangeData = Array.from(Array(800).keys()).map((d: any, i: number) => ({ index: i, from: '', to: '', selected: false }));
	const [rangeData, setRangeData] = useState<any>(initialRangeData);
	const [operator, setOperator] = useState<string>('1');
	const [dataRuleName, setDataRuleName] = useState<string>("");
	const [dataRule, setDataRule] = useState<any>();
	const [dataRules, setDataRules] = useState<any[]>([]);
	const [selectedDataRuleId, setSelectedDataRuleId] = useState<any>();
	const [selectedDataElementIds, setSelectedDataElementIds] = useState<any[]>();
	const [selectedDataElements, setSelectedDataElements] = useState<any[]>([]);
	const [dataElements, setDataElements] = useState<any[]>([]);
	const FADS_BASE_URL = process.env.FADS_GATEWAY_URL;
	const updateDataRuleUrl = FADS_BASE_URL+ urlConfig.updateDataRuleUrlEndPoint;
	const getDataRuleUrl = FADS_BASE_URL+ urlConfig.getDataRuleUrlEndPoint;


	let dataElementsTableConfig = {
		columns: [
			{ field: '', sortable: false, filterable: false, renderCell: (props: any) => { return <input type="radio" checked={selectedDataRuleId === props.row.id} value={props.row.id} onChange={(e: any) => { setSelectedDataRuleId(parseInt(e.target.value)) }} /> }, minWidth: 30 },
			{ field: "dataSource", headerName: 'Data Source', flex: 1, minWidth: 200,type: 'singleSelect', valueOptions: ['All', 'Provider', 'Member', 'Claim'] },
			{ field: "name", headerName: 'Data Element', flex: 1, minWidth: 100 }
		],
		url: FADS_BASE_URL+ urlConfig['createDataRuleElements']
	};

	const onRangeTableChange = (row: any) => {
		const updatedRecords = rangeData.map((d: any, i: number) => {
			if (row.index === d.index) {
				if(row.from===0 && row.to ===0 ) row={index:d.index,from:"",to:""};
				return row;
			}
			return d;
		});
		setRangeData(updatedRecords);
	};

	const onRangeDataImport = (rows: any[]) => {
		let lastIndex = -1;
		rangeData.forEach((d: any, i: number) => {
			if (d.from || d.to) { lastIndex = i; }
		});
		let rowsIndex = -1;
		const updatedRecords = rangeData.map((d: any, i: number) => {
			if (lastIndex >= i) { return d; }
			rowsIndex++;
			if(rowsIndex >= rows?.length) {return d;}
			return { ...d, from: rows[rowsIndex][0], to: rows[rowsIndex][1] };
		});

		setRangeData(updatedRecords);
	}
	const onRangeRowsRemove = () => {
		let updatedRecords = rangeData.filter((d: any, i: number) => {
			return !d.selected;
		});
		while (updatedRecords.length < 800) {
			updatedRecords.push({ from: '', to: '', selected: false });
		}
		updatedRecords = updatedRecords.map((d: any, i: number) => ({ ...d, index: i }));
		setRangeData(updatedRecords);
	}

	React.useEffect(() => {
		setRangeData(initialRangeData); 
		setSelectedDataElementIds([]);
	}, [dataElementSelection]);

	const onChangeToggle = () => {
		setOperator(operator === '1' ? '2' : '1')
	}
	React.useEffect(() => {
		getAllDataRules();
	},[]);

	React.useEffect(() => {
		if(dataRules && dataRules.length > 0  && props?.dataRuleId){ 
			getDataRuleById(props.dataRuleId)
		}
	},[dataRules]);

	const getAllDataRules = () => {
		const token = localStorage.getItem("id_token");
		fetch(dataElementsTableConfig.url, {
			method: "GET",
			mode: "cors",
			headers: {
				"access-control-allow-origin": "*",
				"Content-type": "application/json; charset=UTF-8",
				Authorization: `Bearer ${token}`,
			},
		})
			.then((response) => {
				return response.json();
			}).then((rules: any[]) => {
				setDataRules(rules);  
			});
	}


	React.useEffect(() => {
		if (!selectedDataRuleId) {
			return;
		}
		setDataElementSelection(dataRules.find((rule: any) => rule.id === selectedDataRuleId));
		
		const token = localStorage.getItem("id_token");
		fetch(pickListCOnfig.url, {
			method: "GET",
			mode: "cors",
			headers: {
				"access-control-allow-origin": "*",
				"Content-type": "application/json; charset=UTF-8",
				Authorization: `Bearer ${token}`,
			},
		})
			.then((response) => {
				return response.json();
			}).then((els: any) => {
				setDataElements(els.availValues.map((e: any) => ({ ...e, id: e.code })));	
				if(dataRule?.selectedValues){
					setSelectedDataElementIds(dataRule.selectedValues.map((s:any) => s.code))
				}
				if(dataRule?.rangeValues && dataRule?.rangeValues.length >0){
					dataRule?.rangeValues.map((r:any,index:number) => {
						if(initialRangeData.length > index){
							initialRangeData[index].from=r.from;
							initialRangeData[index].to=r.to;
						}
					});
					setRangeData(initialRangeData);
				}
			});
	}, [selectedDataRuleId]);

	React.useEffect(() => { 
		setSelectedDataElements(dataElements.filter((el: any) => selectedDataElementIds?.includes(el.id)));
	}, [selectedDataElementIds]);

	const selectedDataRuleIdUrl = FADS_BASE_URL + urlConfig["selectedDataRuleIdUrl"]

	const pickListCOnfig = {
		
		url: selectedDataRuleIdUrl.replace('{selectedDataRuleId}', selectedDataRuleId),
		columns: [
			{ headerName: "Code", field: "code", flex: 1, minWidth: 10 },
			{ headerName: "Description", field: "value", flex: 1, minWidth: 100 }
		],
		getTagLabel: (row: any) => { return row?.value; }
	} 

	const getDataRuleById =(id:any) => {
		const token = localStorage.getItem("id_token");
		fetch(getDataRuleUrl.replace("{dataRuleId}", id), {
			method: "GET",
			mode: "cors",
			headers: {
				"access-control-allow-origin": "*",
				"Content-type": "application/json; charset=UTF-8",
				Authorization: `Bearer ${token}`,
			},
		}).then((response) => {
			return response.json();
		}).then((existingDataRule: any) => {
			setDataRule(existingDataRule)
			setDataRuleName(existingDataRule.dataRuleName)
			setOperator(existingDataRule.operator)
			setSelectedDataRuleId(existingDataRule?.dataElementId);
			
		});
	}

	const updateDataRule = async () => {
		let newDataRule = {...dataRule}
		newDataRule.dataRuleName=dataRuleName;
		newDataRule.dataElementId = selectedDataRuleId ;
		newDataRule.dataElementName= "";
		newDataRule.operator= operator ;
		let selectedDataElements = [];
		if(selectedDataElementIds && selectedDataElementIds.length && dataElements?.length){
			selectedDataElements = selectedDataElementIds.map((code: any) => {
				let dataElement = dataElements.find((dataElement: any) => dataElement.code === code);
				delete dataElement.id;
				return dataElement;
			})
		}
		newDataRule.selectedValues = selectedDataElements.length ? selectedDataElements : newDataRule.selectedValues;
		newDataRule.rangeValues = rangeData?.filter((range:any) => range?.from && range?.to)
		if(dataElementSelection?.luFlag === '1' ){
			newDataRule.rangeValue="novalue"
		}else{
			newDataRule.rangeValue="hasvalue"
		}
		//api call for update
		const token = localStorage.getItem("id_token");
		const url = updateDataRuleUrl.replace("{dataRuleId}", dataRule?.dataRuleId);

        await putData(url, newDataRule, PGP_SUCCESS_MSG.DATA_RULE_UPDATE);
		props?.onSave();
	}
	const onSave = () => {
		updateDataRule();		
	}
	const isNameEmpty = !dataRuleName?.trim();
	
	const updateBtnDisabled = isNameEmpty || pgpUserAccess === PGP_USER_ACCESS.READ_ONLY || 
        (pgpUserAccess === PGP_USER_ACCESS.BASIC && userData?.userSystemId !== dataRule?.createdBySystemId);

	return (
	<>
	<Dialog heading="Data Rule Detail - Update" open={true} onClose={props?.onClose} footer={true} className="studies-add-activity">
		<Wrapper className="wrapper-color-black">
		<Description>Rename and/or re-define the Data Rule by selecting a different code value/range or selecting a different Data Element.</Description>

		<FormFieldContainer>
			<div>
				<Label>Data Rule Name <Required>*</Required></Label>
				<TextInput className="textInput" maxLength={50} value={dataRuleName} onChange={(e:any)=>{setDataRuleName(e.target.value)}}/>
			</div>
		</FormFieldContainer>

		<DataRuleSelectionWrapper>
			<Label>Choose one Data Element to begin building a Data Rule<Required>*</Required></Label>
		</DataRuleSelectionWrapper>

		<div style={{ height: 566, overflow: 'auto' }}>
			<DataGrid
				columns={dataElementsTableConfig.columns}
				rows={dataRules}
				hideToolbarRowCount
				disableCsvExport
				disableExcelExport
				disablePrintExport
				hideFooter
				pagination={false}
				disableAdvanceFilters
			/>
		</div>

		{selectedDataRuleId && <RangeInfo>
			Instances where <b>{dataElementSelection?.name}</b> {dataElementSelection?.luFlag === '0' ? 'is in the range below' : 'equals'}:
			<SwitchContainer>
				<Switch checked={operator === "1"} onChange={onChangeToggle} />
				<span style={{ fontSize: '14px' }}>
					Include
				</span>
			</SwitchContainer>
		</RangeInfo>}


		{selectedDataRuleId && dataElementSelection?.luFlag === '1' && <>
			<div style={{display:'flex'}}>
				<div style={{flex:2,height:"400px",overflowY: 'scroll' }}>
					<h6 style={{margin:'0 0 8px 0'}}>Select from Available Code Values</h6>
					<DataGrid
						columns={pickListCOnfig.columns}
						rows={dataElements}
						hideToolbarRowCount
						disableCsvExport
						disableExcelExport
						disablePrintExport
						hideFooter
						pagination={false}
						checkboxSelection={true}
						rowSelectionModel={selectedDataElementIds}
						onRowSelectionModelChange={setSelectedDataElementIds}
					/>

				</div>
				<TagList>
					<h6>Selected Code Value(s)<Required>*</Required></h6>
					<OSGPList
						// filtered out data based on the list of selected row ids
						data={selectedDataElements}
						sx={{ width: 'fit-content' }}
						listItemTemplate={({ listItemData }: OSGPListItemTemplateProps) => (
							<Tag
								sx={{ width: 'fit-content', justifyContent: "left" }}
								leftAlignDeleteIcon
								label={pickListCOnfig.getTagLabel(listItemData)}
								// deleting the particular row id from the list of selected row ids upon deleting the tag from the list
								onDelete={() => setSelectedDataElementIds?.((selectedDataElementIds || []).filter((val: any) => val !== listItemData.id))}
							/>
						)}
						height="400px"
					/>
				</TagList>
			</div>
		</>}
		{selectedDataRuleId && dataElementSelection?.luFlag === '0' && <RangeTable data={rangeData} onRangeTableChange={onRangeTableChange} onRangeDataImport={onRangeDataImport} onRangeRowsRemove={onRangeRowsRemove} />}
			<Grid container spacing={2} >
				<Grid item>
					<Button disabled={updateBtnDisabled} onPress={onSave}>Update</Button>
				</Grid>
				<Grid item>
					<Button onPress={props.onClose} variant="ghost">Cancel</Button>
				</Grid> 
			</Grid> 
		</Wrapper>
	</Dialog>
	</>);

}
