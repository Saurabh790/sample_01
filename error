@Override
@Transactional
public void scheduleStudyJob(Study study) {
    LocalDateTime now = LocalDateTime.now();

    JobMasterT jobMaster = new JobMasterT();
    jobMaster.setJobId(jobsRepository.getNextJobId());
    jobMaster.setCreateDte(Date.from(now.atZone(ZoneId.systemDefault()).toInstant()));
    jobMaster.setArcFlag(0);
    jobMaster.setHoldFlag(0);
    jobMaster.setPurgeFlag(0);

    // If you compute purgeDate:
    fadsConfigRepository.findById(StudyConstants.PURGE_OPTION_CODE).ifPresent(cfg -> {
        Date purgeDate = Date.from(
            now.plusDays(Long.parseLong(cfg.getOptionValue()))
               .atZone(ZoneId.systemDefault()).toInstant());
        jobMaster.setDatePurge(purgeDate);
    });

    // ✅ Link existing rows via getReference (no SELECT, just a proxy)
    UiUserBase creatorRef = uiUserBaseRepository.getReferenceById(study.getCreatedBySystemId());
    UiUserBase updaterRef = uiUserBaseRepository.getReferenceById(study.getUpdatedBySystemId());
    PrmStudyMasterT studyRef = prmStudyMasterRepository.getReferenceById(study.getStudyId());

    // Pick the correct existing status code for “scheduled/created”
    JobLuStatusT statusRef = jobLuStatusRepository.getReferenceById(1L /* e.g., SCHEDULED */);

    jobMaster.setCreateUiUserBase(creatorRef);
    jobMaster.setUpdateUiUserBase(updaterRef);
    jobMaster.setPrmStudyMasterT(studyRef);
    jobMaster.setJobLuStatusT(statusRef);

    // If you intend to store time of run, use TIMESTAMP (see mapping tip below)
    if (study.getScheduleRunDateTime() != null) {
        jobMaster.setDateSched(Date.from(
            study.getScheduleRunDateTime().atZone(ZoneId.systemDefault()).toInstant()));
    }

    jobsRepository.save(jobMaster);
}
