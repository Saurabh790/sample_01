1) DTO (response wrapper like history)
package com.optum.fads.userroles.api.dto;

import java.util.List;

public class UserListResponse {
    private final List<UserListItem> data;
    private final long totalRecordsCount;

    public UserListResponse(List<UserListItem> data, long totalRecordsCount) {
        this.data = data;
        this.totalRecordsCount = totalRecordsCount;
    }

    public List<UserListItem> getData() { return data; }
    public long getTotalRecordsCount() { return totalRecordsCount; }
}

(Your existing UserListItem stays as-is.)

2) Controller (history-style)
package com.optum.fads.userroles.api.controllers;

import com.optum.fads.userroles.api.dto.UserListResponse;
import com.optum.fads.userroles.api.service.IUserList;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.web.bind.annotation.*;

@RestController
public class UserRolesControllerV2 {

    private static final String DEFAULT_SORT_FIELD = "lastName";

    private final IUserList userListService;

    public UserRolesControllerV2(IUserList userListService) {
        this.userListService = userListService;
    }

    @GetMapping("/api/users")
    public UserListResponse getUsers(
            @RequestParam(defaultValue = "1")  int pageNumber,
            @RequestParam(defaultValue = "10") int recordsPerPage,
            @RequestParam(defaultValue = DEFAULT_SORT_FIELD) String sortBy,
            @RequestParam(defaultValue = "1")  int sortOrder,
            @RequestParam(required = false)     String searchBy,
            @RequestParam(required = false)     String searchInput
    ) {

        // map DTO sort to entity path (dot-notation ok for Sort)
        String entitySortField = mapToEntityField(sortBy);

        Sort.Direction direction = (sortOrder == -1) ? Sort.Direction.DESC : Sort.Direction.ASC;
        Sort sort = Sort.by(direction, entitySortField);

        Pageable pageable = PageRequest.of(Math.max(pageNumber - 1, 0), recordsPerPage, sort);

        return userListService.getAllUsers(pageable, searchBy, searchInput);
    }

    /**
     * Map API sort fields → entity field paths (like history controller).
     * Supports nested sort on joined associations.
     */
    private String mapToEntityField(String dtoField) {
        return switch (dtoField) {
            case "uiSystemId" -> "uiSystemId";
            case "uiUserId"   -> "uiUserId";
            case "lastName"   -> "uiLastName";
            case "firstName"  -> "uiFirstName";
            case "title"      -> "uiTitle";
            case "email"      -> "uiEMailAddress";
            // nested names:
            case "fadsGrpName" -> "seUsrGrp.fadsGrp.fadsGrpName";
            case "surGrpName"  -> "seUsrGrp.fadsSurGrp.surGrpName";
            case "caseGrpName" -> "seUsrGrp.fadsCaseGrp.caseGrpName";
            default -> DEFAULT_SORT_FIELD.equals(dtoField) ? "uiLastName" : "uiLastName";
        };
    }
}


You can keep your old controller if you want; just don’t register both endpoints with the same path.


3) Service interface (history-style)
package com.optum.fads.userroles.api.service;

import com.optum.fads.userroles.api.dto.UserListResponse;
import org.springframework.data.domain.Pageable;

public interface IUserList {
    UserListResponse getAllUsers(Pageable pageable, String searchBy, String searchInput);
}


4) Service implementation (joins + spec, mirrors history)
package com.optum.fads.userroles.api.service.impl;

import com.optum.fads.userroles.api.domain.UiUserBase;
import com.optum.fads.userroles.api.dto.UserListItem;
import com.optum.fads.userroles.api.dto.UserListResponse;
import com.optum.fads.userroles.api.mapper.UserListItemMapper;
import com.optum.fads.userroles.api.repo.UiUserBaseRepository;
import com.optum.fads.userroles.api.service.IUserList;
import jakarta.persistence.criteria.Join;
import jakarta.persistence.criteria.JoinType;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import java.util.List;
import java.util.Locale;

@Service
public class UserListImpl implements IUserList {

    private static final String FIELD_UI_SYSTEM_ID = "uiSystemId";
    private static final String FIELD_UI_USER_ID   = "uiUserId";
    private static final String FIELD_LAST_NAME    = "uiLastName";
    private static final String FIELD_FIRST_NAME   = "uiFirstName";
    private static final String FIELD_TITLE        = "uiTitle";
    private static final String FIELD_EMAIL        = "uiEMailAddress";

    // nested “name” fields in SE_USR_GRP → groups
    private static final String FIELD_FADS_NAME = "fadsGrpName";
    private static final String FIELD_SUR_NAME  = "surGrpName";
    private static final String FIELD_CASE_NAME = "caseGrpName";

    private final UiUserBaseRepository repository;
    private final UserListItemMapper mapper;

    public UserListImpl(UiUserBaseRepository repository, UserListItemMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    public UserListResponse getAllUsers(Pageable pageable, String searchBy, String searchInput) {
        Page<UiUserBase> page;

        if (StringUtils.hasText(searchBy) && StringUtils.hasText(searchInput)) {
            Specification<UiUserBase> spec = createSearchSpecification(searchBy, searchInput);
            page = repository.findAll(spec, pageable);
        } else {
            page = repository.findAll(pageable);
        }

        List<UserListItem> data = page.getContent().stream().map(mapper::toDto).toList();
        return new UserListResponse(data, page.getTotalElements());
    }

    /**
     * Build a single-field search spec (like your history service),
     * with LEFT joins for group name fields.
     */
    private Specification<UiUserBase> createSearchSpecification(String searchBy, String searchInput) {
        final String pattern = "%" + searchInput.toLowerCase(Locale.ROOT) + "%";

        return (root, query, cb) -> {
            // If we will join, force distinct
            boolean needsJoin =
                    FIELD_FADS_NAME.equals(searchBy) ||
                    FIELD_SUR_NAME.equals(searchBy)  ||
                    FIELD_CASE_NAME.equals(searchBy);
            if (needsJoin) {
                query.distinct(true);
            }

            switch (searchBy) {
                case FIELD_UI_SYSTEM_ID:
                case FIELD_UI_USER_ID:
                case FIELD_LAST_NAME:
                case FIELD_FIRST_NAME:
                case FIELD_TITLE:
                case FIELD_EMAIL:
                    return cb.like(cb.lower(root.get(searchByToEntityColumn(searchBy))), pattern);

                case FIELD_FADS_NAME: {
                    // join seUsrGrp → fadsGrp → fadsGrpName
                    Join<?, ?> jUsrGrp = root.join("seUsrGrp", JoinType.LEFT);
                    Join<?, ?> jFads   = jUsrGrp.join("fadsGrp", JoinType.LEFT);
                    return cb.like(cb.lower(jFads.get("fadsGrpName")), pattern);
                }
                case FIELD_SUR_NAME: {
                    Join<?, ?> jUsrGrp = root.join("seUsrGrp", JoinType.LEFT);
                    Join<?, ?> jSur    = jUsrGrp.join("fadsSurGrp", JoinType.LEFT);
                    return cb.like(cb.lower(jSur.get("surGrpName")), pattern);
                }
                case FIELD_CASE_NAME: {
                    Join<?, ?> jUsrGrp = root.join("seUsrGrp", JoinType.LEFT);
                    Join<?, ?> jCase   = jUsrGrp.join("fadsCaseGrp", JoinType.LEFT);
                    return cb.like(cb.lower(jCase.get("caseGrpName")), pattern);
                }

                default:
                    // Safe default search: email contains
                    return cb.like(cb.lower(root.get(FIELD_EMAIL)), pattern);
            }
        };
    }

    /** map request searchBy to entity column names (simple fields only) */
    private String searchByToEntityColumn(String searchBy) {
        return switch (searchBy) {
            case FIELD_UI_SYSTEM_ID -> FIELD_UI_SYSTEM_ID;
            case FIELD_UI_USER_ID   -> FIELD_UI_USER_ID;
            case FIELD_LAST_NAME    -> FIELD_LAST_NAME;
            case FIELD_FIRST_NAME   -> FIELD_FIRST_NAME;
            case FIELD_TITLE        -> FIELD_TITLE;
            case FIELD_EMAIL        -> FIELD_EMAIL;
            default -> FIELD_EMAIL;
        };
    }
}


Note: .distinct(true) prevents duplicates when sorting/ filtering on joined tables.


5) Repository, Entities, Mapper


Your existing entities, UiUserBaseRepository (extends JpaSpecificationExecutor), and UserListItemMapper are already compatible with this approach. Keep them as you posted.



6) Example requests
GET /api/users?pageNumber=1&recordsPerPage=20&sortBy=fadsGrpName&sortOrder=1

GET /api/users?searchBy=lastName&searchInput=smith&sortBy=firstName&sortOrder=1

GET /api/users?searchBy=fadsGrpName&searchInput=Audit


7) What to remove from the old user API


The FIELD_MAP and the generic UserSpecification helper class (not needed now).


The /findAllByPageable path if you don’t need it — or keep both during migration.



Why this mirrors your History API


Same controller structure (map sort field, build Pageable)


Same parameter shape (searchBy, searchInput)


Same service approach (single-field Specification, targeted joins)


Same response contract ({ data, totalRecordsCount })


If you want multi-field search later, we can extend createSearchSpecification to AND multiple predicates (like your first approach), but the skeleton above stays true to your history-style implementation.
