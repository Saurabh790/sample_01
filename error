// PemKeyLoader.java
package com.optum.fads.pgp.jobs.api.config;

import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openssl.PEMEncryptedKeyPair;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import org.bouncycastle.openssl.jcajce.JceOpenSSLPKCS8DecryptorProviderBuilder;
import org.bouncycastle.operator.InputDecryptorProvider;
import org.bouncycastle.pkcs.PKCS8EncryptedPrivateKeyInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.StringReader;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.Security;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.spec.RSAPrivateCrtKeySpec;

public class PemKeyLoader {

    private static final Logger logger =
            LoggerFactory.getLogger(PemKeyLoader.class);

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    public static PrivateKey loadPrivateKeyPem(String pemContent, char[] passphrase) throws Exception {
        logger.debug("Parsing PEM content...");
        try (PEMParser pemParser = new PEMParser(new StringReader(pemContent))) {
            Object pemObject = pemParser.readObject();
            PrivateKeyInfo privateKeyInfo = null;

            if (pemObject instanceof PKCS8EncryptedPrivateKeyInfo) {
                if (passphrase == null) {
                    throw new IllegalArgumentException(
                            "Encrypted key found but no passphrase provided."
                    );
                }
                logger.debug("Detected PKCS#8 encrypted key.");
                PKCS8EncryptedPrivateKeyInfo encInfo =
                        (PKCS8EncryptedPrivateKeyInfo) pemObject;
                InputDecryptorProvider decProv =
                        new JceOpenSSLPKCS8DecryptorProviderBuilder().build(passphrase);
                privateKeyInfo = encInfo.decryptPrivateKeyInfo(decProv);

            } else if (pemObject instanceof PEMEncryptedKeyPair) {
                logger.debug("Detected old-format encrypted key (PEM).");
                // Add necessary decryption if needed
            } else if (pemObject instanceof PrivateKeyInfo) {
                logger.debug("Detected unencrypted PKCS#8 key.");
                privateKeyInfo = (PrivateKeyInfo) pemObject;
            } else {
                logger.debug("Unknown PEM object type: {}",
                        pemObject == null ? "null" : pemObject.getClass().getName());
            }

            // Convert to BC key first
            JcaPEMKeyConverter converter = new JcaPEMKeyConverter()
                    .setProvider(BouncyCastleProvider.PROVIDER_NAME);
            PrivateKey bcKey = converter.getPrivateKey(privateKeyInfo);

            // Convert BC key to standard JDK RSA key
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey) bcKey;

            RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(
                    rsaKey.getModulus(),
                    rsaKey.getPublicExponent(),
                    rsaKey.getPrivateExponent(),
                    rsaKey.getPrimeP(),
                    rsaKey.getPrimeQ(),
                    rsaKey.getPrimeExponentP(),
                    rsaKey.getPrimeExponentQ(),
                    rsaKey.getCrtCoefficient()
            );

            PrivateKey jdkKey = keyFactory.generatePrivate(keySpec);
            logger.debug("Key conversion successful? {}", jdkKey != null);
            logger.debug("Key class: {}", jdkKey.getClass().getName());

            return jdkKey;
        }
    }
}
package com.optum.fads.pgp.jobs.api.config;

import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.optum.fads.pgp.jobs.api.security.UserJwtAuthenticationConverter;
import com.optum.fads.pgp.jobs.api.service.IUserDetailsService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.factory.PasswordEncoderFactories;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import com.nimbusds.jwt.JWT;
import com.nimbusds.jwt.JWTParser;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final IUserDetailsService userDetailsService;

    private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);

    public SecurityConfig(IUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

        http.csrf(csrf -> csrf
                        .ignoringRequestMatchers("/actuator/**", "/api/**")
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth.requestMatchers("/actuator/**").permitAll()
                        .anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt
                                .decoder(jwtDecoder())
                                .jwtAuthenticationConverter(userJwtAuthenticationConverter())
                        )
                );

        return http.build();
    }

    @Bean
    public JwtDecoder jwtDecoder() {
        // Custom JWT decoder that skips signature validation
        return token -> {
            try {
                JWT jwt = JWTParser.parse(token);

                // Convert claims, handling Date to Instant conversion
                Map<String, Object> claims = new HashMap<>(jwt.getJWTClaimsSet().getClaims());

                convertDateToInstant(claims, "iat");  // issued at
                convertDateToInstant(claims, "exp");  // expires at
                convertDateToInstant(claims, "nbf");  // not before
                convertDateToInstant(claims, "auth_time");  // authentication time

                return Jwt.withTokenValue(token)
                        .headers(headers -> headers.putAll(jwt.getHeader().toJSONObject()))
                        .claims(claimsMap -> claimsMap.putAll(claims))
                        .build();
            } catch (Exception e) {
                throw new JwtException("Failed to parse JWT", e);
            }
        };
    }

    private void convertDateToInstant(Map<String, Object> claims, String claimName) {
        Object value = claims.get(claimName);
        if (value instanceof Date) {
            claims.put(claimName, ((Date) value).toInstant());
        }
    }

    @Bean
    UserJwtAuthenticationConverter userJwtAuthenticationConverter() {
        return new UserJwtAuthenticationConverter(userDetailsService);
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return PasswordEncoderFactories.createDelegatingPasswordEncoder();
    }

    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Collections.singletonList(CorsConfiguration.ALL));
        configuration.setAllowedMethods(Collections.singletonList(CorsConfiguration.ALL));
        configuration.setAllowedHeaders(Collections.singletonList(CorsConfiguration.ALL));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        logger.info("CORS configuration registered for all paths");
        return source;
    }
}
package com.optum.fads.pgp.jobs.api.config;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.azure.security.keyvault.secrets.SecretClient;

import javax.sql.DataSource;

/**
 * @author sbajaj8
 */
@Configuration
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
@EnableTransactionManagement
@EnableJpaRepositories(entityManagerFactoryRef = "sqlEntityManagerFactory",
        transactionManagerRef = "txManagerSQL",
        basePackages = "com.optum.fads.pgp.jobs.api.repo")
public class ServiceConfigSQL {

    @Value("${spring.datasource.sql.userName}")
    private String userName;

    @Value("${spring.datasource.sql.password}")
    private String password;

    @Value("${spring.datasource.sql.jdbcUrl}")
    private String url;

    @Value("${spring.datasource.sql.driverClassName}")
    private String driverClassName;

    private final SecretClient secretClient;

    public ServiceConfigSQL(SecretClient secretClient) {
        this.secretClient = secretClient;
    }

    @Bean(name = "fadsSQLDataSource")
    @Primary
    public DataSource fadsSQLDataSource() {
        System.out.println("Establishing sql connection");
        String userNameValue;
        String passwordValue;

        try {
            userNameValue = secretClient.getSecret(userName).getValue();
            passwordValue = secretClient.getSecret(password).getValue();
        } catch (Exception e) {
            throw new RuntimeException("Failed to retrieve secrets from Azure Key Vault", e);
        }
        System.out.println("UserName: " + userNameValue);
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(driverClassName);
        dataSource.setUsername(userNameValue);
        dataSource.setPassword(passwordValue);
        dataSource.setUrl(url);

        return dataSource;
    }

    @Bean(name = "sqlEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean sqlEntityManagerFactory() {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(fadsSQLDataSource());
        em.setPackagesToScan("com.optum.fads.pgp.jobs.api.domain");

        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);

        // Set Hibernate properties
        java.util.Properties properties = new java.util.Properties();
        properties.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQLDialect"); // Replace with your database dialect
        em.setJpaProperties(properties);

        return em;
    }


    @Bean(name = "txManagerSQL")
    public PlatformTransactionManager txManagerSQL(@Qualifier("sqlEntityManagerFactory") EntityManagerFactory sqlEntityManagerFactory) {
        JpaTransactionManager txManager = new JpaTransactionManager();
        txManager.setEntityManagerFactory(sqlEntityManagerFactory().getObject());
        return txManager;
    }

}


	

