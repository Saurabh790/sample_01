Got it — these errors are happening because your project currently has a mix of “old files” + “new files I suggested”, and also because I accidentally used Spring Batch 5 style builders (new JobBuilder(name, repo)) which does NOT work in Spring Boot 2.7 / Spring Batch 4.
So we’ll fix this cleanly in 2 steps:
✅ A) Delete/disable old conflicting classes (TxnProcessor, RoutingWriter, etc.)
✅ B) Replace InvoiceJobConfig with a Spring Batch 4 compatible one (Boot 2.7)
Below are the exact complete file replacements you should do.

✅ Step 1 — Remove these old classes (IMPORTANT)
In src/main/java/com/optum/fads/caseentrybatch/poc/batch/, delete these if they exist:


TxnProcessor.java


RoutingWriter.java


TxnSourceRow.java (if exists)


ProcessedTxn.java (if it’s not the one below)


any “reader config” you created earlier that has SpEL jobParameters without @StepScope


These are causing most of your 46 errors.

✅ Step 2 — Create these packages (IMPORTANT)
You got error: package ...batch.model does not exist
So create folder structure:
src/main/java/com/optum/fads/caseentrybatch/poc/batch/model/
And put the 2 model files below inside it.

✅ FILE 1: src/main/java/com/optum/fads/caseentrybatch/poc/batch/model/TxnSource.java
package com.optum.fads.caseentrybatch.poc.batch.model;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.time.LocalDate;

public class TxnSource {
  private Long txnId;
  private String customerId;
  private String productId;
  private BigDecimal txnAmount;
  private Timestamp txnTime;
  private String currency;
  private String channel;
  private LocalDate invoiceDate;
  private String status;

  public Long getTxnId() { return txnId; }
  public void setTxnId(Long txnId) { this.txnId = txnId; }

  public String getCustomerId() { return customerId; }
  public void setCustomerId(String customerId) { this.customerId = customerId; }

  public String getProductId() { return productId; }
  public void setProductId(String productId) { this.productId = productId; }

  public BigDecimal getTxnAmount() { return txnAmount; }
  public void setTxnAmount(BigDecimal txnAmount) { this.txnAmount = txnAmount; }

  public Timestamp getTxnTime() { return txnTime; }
  public void setTxnTime(Timestamp txnTime) { this.txnTime = txnTime; }

  public String getCurrency() { return currency; }
  public void setCurrency(String currency) { this.currency = currency; }

  public String getChannel() { return channel; }
  public void setChannel(String channel) { this.channel = channel; }

  public LocalDate getInvoiceDate() { return invoiceDate; }
  public void setInvoiceDate(LocalDate invoiceDate) { this.invoiceDate = invoiceDate; }

  public String getStatus() { return status; }
  public void setStatus(String status) { this.status = status; }
}


✅ FILE 2: src/main/java/com/optum/fads/caseentrybatch/poc/batch/model/ProcessedTxn.java
package com.optum.fads.caseentrybatch.poc.batch.model;

import java.math.BigDecimal;
import java.time.LocalDate;

public class ProcessedTxn {
  private Long txnId;
  private String jobRunId;
  private LocalDate invoiceDate;
  private String customerId;

  private BigDecimal baseAmount;
  private BigDecimal discount;
  private BigDecimal tax;
  private BigDecimal commission;
  private BigDecimal netAmount;

  public Long getTxnId() { return txnId; }
  public void setTxnId(Long txnId) { this.txnId = txnId; }

  public String getJobRunId() { return jobRunId; }
  public void setJobRunId(String jobRunId) { this.jobRunId = jobRunId; }

  public LocalDate getInvoiceDate() { return invoiceDate; }
  public void setInvoiceDate(LocalDate invoiceDate) { this.invoiceDate = invoiceDate; }

  public String getCustomerId() { return customerId; }
  public void setCustomerId(String customerId) { this.customerId = customerId; }

  public BigDecimal getBaseAmount() { return baseAmount; }
  public void setBaseAmount(BigDecimal baseAmount) { this.baseAmount = baseAmount; }

  public BigDecimal getDiscount() { return discount; }
  public void setDiscount(BigDecimal discount) { this.discount = discount; }

  public BigDecimal getTax() { return tax; }
  public void setTax(BigDecimal tax) { this.tax = tax; }

  public BigDecimal getCommission() { return commission; }
  public void setCommission(BigDecimal commission) { this.commission = commission; }

  public BigDecimal getNetAmount() { return netAmount; }
  public void setNetAmount(BigDecimal netAmount) { this.netAmount = netAmount; }
}


✅ FILE 3 (REPLACE): src/main/java/com/optum/fads/caseentrybatch/poc/batch/InvoiceJobConfig.java
This is Spring Boot 2.7 / Spring Batch 4 compatible ✅
No JobRepository constructor builder (that is Batch 5).
Also: BeanPropertyItemSqlParameterSourceProvider is not needed here; we use BeanPropertyItemPreparedStatementSetter.
package com.optum.fads.caseentrybatch.poc.batch;

import com.optum.fads.caseentrybatch.poc.batch.model.ProcessedTxn;
import com.optum.fads.caseentrybatch.poc.batch.model.TxnSource;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.BeanPropertyItemPreparedStatementSetter;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.BeanPropertyRowMapper;

import javax.sql.DataSource;
import java.time.LocalDate;

@Configuration
@EnableBatchProcessing
public class InvoiceJobConfig {

  @Bean
  public Job invoiceJob(JobBuilderFactory jobs, Step invoiceStep) {
    return jobs.get("invoiceJob")
        .incrementer(new RunIdIncrementer())
        .start(invoiceStep)
        .build();
  }

  @Bean
  public Step invoiceStep(
      StepBuilderFactory steps,
      JdbcCursorItemReader<TxnSource> txnReader,
      ItemProcessor<TxnSource, ProcessedTxn> txnProcessor,
      JdbcBatchItemWriter<ProcessedTxn> finalLineWriter
  ) {
    return steps.get("invoiceStep")
        .<TxnSource, ProcessedTxn>chunk(10)
        .reader(txnReader)
        .processor(txnProcessor)
        .writer(finalLineWriter)
        .build();
  }

  // -------- Reader (StepScope because it uses jobParameters) --------
  @Bean
  @StepScope
  public JdbcCursorItemReader<TxnSource> txnReader(
      DataSource dataSource,
      @Value("#{jobParameters['invoiceDate']}") String invoiceDateStr
  ) {
    LocalDate invoiceDate = (invoiceDateStr == null || invoiceDateStr.isBlank())
        ? LocalDate.of(2026, 1, 24)
        : LocalDate.parse(invoiceDateStr);

    return new JdbcCursorItemReaderBuilder<TxnSource>()
        .name("txnReader")
        .dataSource(dataSource)
        .sql("SELECT txn_id, customer_id, product_id, txn_amount, txn_time, currency, channel, invoice_date, status " +
             "FROM TXN_SOURCE WHERE invoice_date = ? AND status = 'N' ORDER BY txn_id")
        .preparedStatementSetter(ps -> ps.setDate(1, java.sql.Date.valueOf(invoiceDate)))
        .rowMapper(new BeanPropertyRowMapper<>(TxnSource.class))
        .build();
  }

  // -------- Processor (StepScope because it uses jobParameters) --------
  @Bean
  @StepScope
  public ItemProcessor<TxnSource, ProcessedTxn> txnProcessor(
      @Value("#{jobParameters['runId']}") String runId,
      @Value("#{jobParameters['invoiceDate']}") String invoiceDateStr
  ) {
    return item -> {
      String effectiveRunId = (runId == null || runId.isBlank())
          ? "RUN_" + System.currentTimeMillis()
          : runId;

      LocalDate invoiceDate = (invoiceDateStr == null || invoiceDateStr.isBlank())
          ? LocalDate.of(2026, 1, 24)
          : LocalDate.parse(invoiceDateStr);

      ProcessedTxn out = new ProcessedTxn();
      out.setTxnId(item.getTxnId());
      out.setJobRunId(effectiveRunId);
      out.setInvoiceDate(invoiceDate);
      out.setCustomerId(item.getCustomerId());

      if (item.getTxnAmount() != null) {
        java.math.BigDecimal base = item.getTxnAmount();
        java.math.BigDecimal discount = base.multiply(new java.math.BigDecimal("0.00"));
        java.math.BigDecimal tax = base.multiply(new java.math.BigDecimal("0.18"));
        java.math.BigDecimal commission = base.multiply(new java.math.BigDecimal("0.02"));
        java.math.BigDecimal net = base.subtract(discount).add(tax).add(commission);

        out.setBaseAmount(base);
        out.setDiscount(discount);
        out.setTax(tax);
        out.setCommission(commission);
        out.setNetAmount(net);
      }

      return out;
    };
  }

  // -------- Writer (writes FINAL_TXN_LINE) --------
  @Bean
  public JdbcBatchItemWriter<ProcessedTxn> finalLineWriter(DataSource dataSource) {
    return new JdbcBatchItemWriterBuilder<ProcessedTxn>()
        .dataSource(dataSource)
        .sql("INSERT INTO FINAL_TXN_LINE " +
             "(txn_id, job_run_id, invoice_date, customer_id, base_amount, discount, tax, commission, net_amount, created_at) " +
             "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)")
        .itemPreparedStatementSetter(new BeanPropertyItemPreparedStatementSetter<ProcessedTxn>() {
          @Override
          public void setValues(ProcessedTxn item, java.sql.PreparedStatement ps) throws java.sql.SQLException {
            ps.setLong(1, item.getTxnId());
            ps.setString(2, item.getJobRunId());
            ps.setDate(3, java.sql.Date.valueOf(item.getInvoiceDate()));
            ps.setString(4, item.getCustomerId());
            ps.setBigDecimal(5, item.getBaseAmount());
            ps.setBigDecimal(6, item.getDiscount());
            ps.setBigDecimal(7, item.getTax());
            ps.setBigDecimal(8, item.getCommission());
            ps.setBigDecimal(9, item.getNetAmount());
          }
        })
        .build();
  }
}


✅ Step 3 — Fix the “ProcessedTxn private access” errors
Those were coming from your old RoutingWriter using fields directly (like p.txnId).
In the model I gave above, fields are private (correct Java), and you must call getters.
But easiest: delete RoutingWriter as I said.

✅ Step 4 — Fix tests: disable job for tests
Create:
src/test/resources/application-test.yml
spring:
  batch:
    job:
      enabled: false

src/test/java/.../DemoApplicationTests.java
package com.optum.fads.caseentrybatch.poc;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

@SpringBootTest
@ActiveProfiles("test")
class DemoApplicationTests {
  @Test
  void contextLoads() {}
}


✅ Now run
mvn clean test

Then:
mvn clean spring-boot:run -Dspring-boot.run.arguments="invoiceDate=2026-01-24 runId=RUN_LOCAL"


Why you got these exact compile errors


new JobBuilder(name, repo) and new StepBuilder(name, repo) → Batch 5 (Boot 3) style ❌


BeanPropertyItemSqlParameterSourceProvider import mismatch (you don’t need it here)


batch.model package not created


Old files (TxnProcessor, RoutingWriter) are still compiling and referencing fields/methods that don’t exist now



If you want, paste the list of files under com/optum/fads/caseentrybatch/poc/batch/ (just filenames) and I’ll tell you exactly which ones to delete/replace so the project compiles in one shot.
