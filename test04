package com.optum.fads.caseentry.api.config;

import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

import org.springframework.jdbc.datasource.DriverManagerDataSource;

import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.azure.security.keyvault.secrets.SecretClient;

import jakarta.persistence.EntityManagerFactory;

@Configuration
@EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class })
@EnableTransactionManagement
@EnableJpaRepositories(
        entityManagerFactoryRef = "sqlEntityManagerFactory",
        transactionManagerRef = "txManagerSQL",
        basePackages = "com.optum.fads.caseentry.api.repo"
)
public class ServiceConfigSQL {

    private static final Logger logger =
            LoggerFactory.getLogger(ServiceConfigSQL.class);

    // Secret names stored in Key Vault
    @Value("${spring.datasource.sql.userName}")
    private String userNameSecretName;

    @Value("${spring.datasource.sql.password}")
    private String passwordSecretName;

    // Normal properties
    @Value("${spring.datasource.sql.jdbcUrl}")
    private String jdbcUrl;

    @Value("${spring.datasource.sql.driverClassName}")
    private String driverClassName;

    private final SecretClient secretClient;

    public ServiceConfigSQL(SecretClient secretClient) {
        this.secretClient = secretClient;
    }

    /**
     * DataSource using Azure Key Vault secrets
     */
    @Bean(name = "fadsSQLDataSource")
    public DataSource fadsSQLDataSource() {

        logger.info("Initializing SQL DataSource using Azure Key Vault...");

        String username =
                secretClient.getSecret(userNameSecretName).getValue();

        String password =
                secretClient.getSecret(passwordSecretName).getValue();

        DriverManagerDataSource dataSource =
                new DriverManagerDataSource();

        dataSource.setDriverClassName(driverClassName);
        dataSource.setUrl(jdbcUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);

        logger.info("SQL DataSource initialized successfully");

        return dataSource;
    }

    /**
     * EntityManagerFactory
     */
    @Bean(name = "sqlEntityManagerFactory")
    public LocalContainerEntityManagerFactoryBean sqlEntityManagerFactory(
            @Qualifier("fadsSQLDataSource") DataSource dataSource) {

        LocalContainerEntityManagerFactoryBean em =
                new LocalContainerEntityManagerFactoryBean();

        em.setDataSource(dataSource);

        em.setPackagesToScan(
                "com.optum.fads.caseentry.api.domain");

        HibernateJpaVendorAdapter vendorAdapter =
                new HibernateJpaVendorAdapter();

        em.setJpaVendorAdapter(vendorAdapter);

        Map<String, Object> properties = new HashMap<>();

        properties.put(
                "hibernate.dialect",
                "org.hibernate.dialect.SQLServer2016Dialect");

        properties.put("hibernate.show_sql", true);
        properties.put("hibernate.format_sql", true);
        properties.put("hibernate.globally_quoted_identifiers", true);
        properties.put("hibernate.allow_update_outside_transaction", true);

        em.setJpaPropertyMap(properties);

        return em;
    }

    /**
     * Transaction Manager
     */
    @Bean(name = "txManagerSQL")
    public PlatformTransactionManager txManagerSQL(
            @Qualifier("sqlEntityManagerFactory")
            EntityManagerFactory emf) {

        JpaTransactionManager txManager =
                new JpaTransactionManager();

        txManager.setEntityManagerFactory(emf);

        return txManager;
    }

}server:
  port: 8080
  servlet:
    contextPath: /caseentry
  error:
    include-binding-errors: always
    include-message: always
#quickstart:
#  generateOrderPeriod: 10s
#  processOrderPeriod: 30s

spring: 
  application:
   name: caseentry
  mvc:
    log-resolved-exception: true
  jpa:
    database-platform: com.optum.fads.caseentry.api.config.SnowflakeDialect
    
    
  cloud:
    azure:
      credential:
        client-id: ${AZURE_KV_CLIENT_ID}
        client-secret: ${AZURE_KV_CLIENT_SECRET}
        tenant-id: ${AZURE_TENANT_ID}
      keyvault:
        secret:
          endpoint: ${AZURE_KV_URL}  
    
  datasource:
     hikari:
      maximum-pool-size: ${MAXIMUM_DB_POOL_SIZE:50}
      minimum-idle: ${MIN_POOL_IDLE:1}
      connection-timeout: ${DB_CONNECTION_TIMEOUT:60000}
      idle-timeout: ${DB_POOL_IDLE_TIMEOUT:60000}
      leak-detection-threshold: ${LEAK_DETETCTION_THRESHOLD:0}
     sql:
       type: com.zaxxer.hikari.HikariDataSource
       jdbcUrl: ${DB_URL}
       userName: ${DB_USR}
       password: ${DB_PWD}
       driverClassName: com.microsoft.sqlserver.jdbc.SQLServerDriver
       jpa:
           database-platform: org.hibernate.dialect.SQLServer2016Dialect
           database: SQL_SERVER 
           format-sql: true
           globally_quoted_identifiers: true
           show-sql: true
           hibernate:
              use-new-id-generator-mappings: true
              globally_quoted_identifiers: true
              hibernate.allow_update_outside_transaction: true
              naming:
                    implicit-strategy: org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyHbmImpl
                    physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy    
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: ${JWKS_URL}
          jws-algorithms: ${JWS_ALG:RS256}
          unique-id-claims: ${JWT_UNIQUE_ID_CLAIMS:upn,unique_name,email,sub}
logging:
#  file:
#    path: /tmp/portal/app/portal_app.log
  level:
    root: INFO
    org.springframework.security: INFO
    org.springframework.web: INFO
    org.hibernate: INFO
#logging:
#  level:
#    org:
#      hibernate:
#        SQL: DEBUG
#        type: TRACE



above is changed prop ile as per secretes

/*
//***********************************************
// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/

package com.optum.fads.caseentry.api.config;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import static org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE;

/**
 * The CommonConfig holds spring based configuration
 */
@Configuration
public class CommonConfig {

    /**
     * Model Mapper for mapping objects
     *
     * @return modelMapper
     */
    @Bean
    @Scope(SCOPE_PROTOTYPE)
    public ModelMapper modelMapper() {
        final var modelMapper = new ModelMapper();
        modelMapper.getConfiguration().setAmbiguityIgnored(true);
        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
        return modelMapper;
    }
}


above is current one of class 

which I hv changed as below
/*
//***********************************************
// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/

package com.optum.fads.caseentry.api.config;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

import com.azure.identity.ClientSecretCredential;
import com.azure.identity.ClientSecretCredentialBuilder;
import com.azure.security.keyvault.secrets.SecretClient;
import com.azure.security.keyvault.secrets.SecretClientBuilder;

import static org.springframework.beans.factory.config.ConfigurableBeanFactory.SCOPE_PROTOTYPE;

/**
 * The CommonConfig holds spring based configuration
 */
@Configuration
public class CommonConfig {

    private static final Logger logger = LoggerFactory.getLogger(CommonConfig.class);

    @Value("${spring.cloud.azure.keyvault.secret.endpoint}")
    private String azureKeyVaultUrl;

    @Value("${spring.cloud.azure.credential.tenant-id}")
    private String azureKeyVaultTenant;

    @Value("${spring.cloud.azure.credential.client-secret}")
    private String azureKeyVaultSecret;

    @Value("${spring.cloud.azure.credential.client-id}")
    private String azureKeyVaultClientId;

    @Bean
    @Scope(SCOPE_PROTOTYPE)
    public ModelMapper modelMapper() {
        final var modelMapper = new ModelMapper();
        modelMapper.getConfiguration().setAmbiguityIgnored(true);
        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
        return modelMapper;
    }

    @Bean
    public SecretClient secretClient() {
        logger.info("Initializing Azure Key Vault SecretClient...");

        ClientSecretCredential clientSecretCredential = new ClientSecretCredentialBuilder()
                .clientId(azureKeyVaultClientId)
                .clientSecret(azureKeyVaultSecret)
                .tenantId(azureKeyVaultTenant)
                .build();

        return new SecretClientBuilder()
                .vaultUrl(azureKeyVaultUrl)
                .credential(clientSecretCredential)
                .buildClient();
    }
}



this is one ore class
package com.optum.fads.caseentry.api.config;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import jakarta.persistence.EntityManagerFactory;

/**
 * @author sbajaj8
 *
 */
@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
@EnableTransactionManagement
@EnableJpaRepositories(entityManagerFactoryRef = "sqlEntityManagerFactory",
						transactionManagerRef = "txManagerSQL",
						basePackages = "com.optum.fads.caseentry.api.repo" )
		public class ServiceConfigSQL 
		{
			@Bean(name = "fadsSQLDataSource")
			@ConfigurationProperties("spring.datasource.sql") 
				public DataSource fadsSQLDataSource() {
					return DataSourceBuilder.create().build(); 
			}
	
			@Bean(name = "sqlEntityManagerFactory")
				public LocalContainerEntityManagerFactoryBean sqlEntityManagerFactory()
					{
						LocalContainerEntityManagerFactoryBean em
								= new LocalContainerEntityManagerFactoryBean();
						em.setDataSource(fadsSQLDataSource());
						em.setPackagesToScan(
								new String[] { "com.optum.fads.caseentry.api.domain" });
						HibernateJpaVendorAdapter vendorAdapter
							= new HibernateJpaVendorAdapter();
						em.setJpaVendorAdapter(vendorAdapter);
					return em;
					}
	 
	 
	 @Bean(name = "txManagerSQL")
	 public PlatformTransactionManager txManagerSQL(@Qualifier("sqlEntityManagerFactory")EntityManagerFactory sqlEntityManagerFactory)
	 {
		 JpaTransactionManager txManager = new JpaTransactionManager();
	        txManager.setEntityManagerFactory(sqlEntityManagerFactory().getObject());
	        return txManager;
	 }
	 
	}


	




which I am thinking how to change  



below is one of sample which i changed in another application  so suggest me what changes I can make in this ServiceConfigSQL

/**
 * 
 */
package com.optum.fads.pgp.study.config;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.azure.security.keyvault.secrets.SecretClient;
/**
 * @author sbiry
 *
 */

@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = { "com.optum.fads.pgp.study.repo"})
@ComponentScan(basePackages = {"com.optum.fads.pgp.study"} )
public class DatasourceConfig {
	
	 private static final Logger logger = LoggerFactory.getLogger(DatasourceConfig.class);
	 
	 	@Value("${spring.datasource.userName}")
	    private String userNameSecretName;

	    @Value("${spring.datasource.password}")
	    private String passwordSecretName;

	    @Value("${spring.datasource.jdbcUrl}")
	    private String jdbcUrl;

	    @Value("${spring.datasource.driverClassName}")
	    private String driverClassName;

	    private final SecretClient secretClient;
	    
	    public DatasourceConfig(SecretClient secretClient) {
	        this.secretClient = secretClient;
	    }

	
	@Bean(name = "fadsDataSource")
    @Primary
    public DataSource customDataSource() {
        logger.info("Initializing custom DataSource bean...");

        String username = secretClient.getSecret(userNameSecretName).getValue();
        String password = secretClient.getSecret(passwordSecretName).getValue();

        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(driverClassName);
        dataSource.setUrl(jdbcUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);

        return dataSource;
    }

}
