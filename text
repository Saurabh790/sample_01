@GetMapping(value = "/findAllByPageable", headers = "Accept=application/json")
public Page<UserListItem> findAllByPageable(
        @RequestParam(name = "pageNumber",     defaultValue = "1")  Integer pageNumber,
        @RequestParam(name = "recordsPerPage", defaultValue = "10") Integer recordsPerPage,
        @RequestParam(name = "sortBy",         defaultValue = "lastName") String sortByCsv,
        @RequestParam(name = "sortOrder",      defaultValue = "1")  String sortOrderCsv,
        @RequestParam(name = "searchBy",       required = false) List<String> searchBy,
        @RequestParam(name = "searchInput",    required = false) List<String> searchInput
) {
    int pageIdx   = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;
    Pageable pg   = buildPageable(sortByCsv, sortOrderCsv, pageIdx, recordsPerPage);
    Map<String,String> filters = buildFilters(searchBy, searchInput);
    return userService.getUsersList(filters, pg, FIELD_MAP);
}

/* ------------ helpers (keep them private in the same controller) ----------- */

private Pageable buildPageable(String sortByCsv, String sortOrderCsv, int pageIdx, int size) {
    List<Sort.Order> orders = buildSort(sortByCsv, sortOrderCsv);
    if (orders.isEmpty()) {
        orders = List.of(Sort.Order.asc(FIELD_MAP.get("lastName")));
    }
    return PageRequest.of(pageIdx, size, Sort.by(orders));
}

private List<Sort.Order> buildSort(String sortByCsv, String sortOrderCsv) {
    List<String> sortBy = Arrays.stream(sortByCsv.split(","))
            .map(String::trim).filter(s -> !s.isBlank()).toList();

    List<Integer> orders = Arrays.stream(sortOrderCsv.split(","))
            .map(String::trim).filter(s -> !s.isBlank())
            .map(v -> "1".equals(v) ? 1 : 0).toList();

    List<Integer> padded = padOrders(orders, sortBy.size());

    List<Sort.Order> result = new ArrayList<>();
    for (int i = 0; i < sortBy.size(); i++) {
        String apiField   = sortBy.get(i);
        String entityPath = FIELD_MAP.get(apiField);
        if (entityPath == null) continue;
        boolean asc = padded.get(i) == 1;
        // IMPORTANT: no .ignoreCase() (avoids DISTINCT/ORDER BY issue in SQL Server)
        result.add(asc ? Sort.Order.asc(entityPath) : Sort.Order.desc(entityPath));
    }
    return result;
}

private List<Integer> padOrders(List<Integer> orders, int targetSize) {
    if (orders.isEmpty()) {
        return Collections.nCopies(targetSize, 1); // default ASC
    }
    List<Integer> out = new ArrayList<>(orders);
    while (out.size() < targetSize) {
        out.add(out.get(out.size() - 1)); // repeat last direction
    }
    return out;
}

private Map<String,String> buildFilters(List<String> searchBy, List<String> searchInput) {
    if (searchBy == null || searchInput == null || searchBy.isEmpty() || searchInput.isEmpty()) {
        return Collections.emptyMap();
    }
    int size = Math.min(searchBy.size(), searchInput.size());
    Map<String,String> map = new LinkedHashMap<>(size);
    for (int i = 0; i < size; i++) {
        map.put(searchBy.get(i), searchInput.get(i));
    }
    return map;
}
