<?xml version="1.0" encoding="UTF-8"?>
<project
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
        xmlns="http://maven.apache.org/POM/4.0.0">

    <modelVersion>4.0.0</modelVersion>

    <groupId>com.optum.fads</groupId>
    <artifactId>fads-pgp-reportsection-api</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.7</version>
        <relativePath/>
    </parent>

    <repositories>
        <repository>
            <id>artifactory</id>
            <name>Artifactory</name>
            <url>https://repo1.uhc.com/artifactory/repo</url>
        </repository>
    </repositories>

    <properties>
        <maven.test.skip>false</maven.test.skip>
        <skipTests>${maven.test.skip}</skipTests>
        <!-- >surefire.skip>${skipTests}</surefire.skip -->
        <failsafe.skip>${skipTests}</failsafe.skip>

        <java.version>17</java.version>
        <spring.boot.version>3.5.7</spring.boot.version>
        <spring.cloud.version>2023.0.2</spring.cloud.version>
        <jasypt.version>2.1.0</jasypt.version>
        <jwt.version>3.8.3</jwt.version>
        <modelmapper.version>3.2.2</modelmapper.version>
        <jacoco.version>0.8.10</jacoco.version>
        <springrunner.version>0.1.0</springrunner.version>
        <guava.version>32.1.2-jre</guava.version>
        <logback.encoder.version>7.4</logback.encoder.version>
        <lombok.version>1.18.28</lombok.version>
        <restassured.version>3.3.0</restassured.version>
        <mockito.version>5.3.1</mockito.version>
        <sonar.exclusions>**/constants/**,**/domain/**</sonar.exclusions>
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version>
        <log4j.version>2.24.3</log4j.version>
        <snakeyaml.version>2.2</snakeyaml.version>
        <jaxb.version>2.3.1</jaxb.version>
        <sonar.version>3.9.1.2184</sonar.version>

    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring.boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring.cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.apache.logging.log4j</groupId>
                <artifactId>log4j-bom</artifactId>
                <version>${log4j.version}</version>
                <scope>import</scope>
                <type>pom</type>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <!-- Spring Boot Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-core</artifactId>
            <version>10.1.47</version>
        </dependency>


        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-resource-server</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-oauth2-jose</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.18.0</version> 
        </dependency>

        <!-- Model Mapper -->
        <dependency>
            <groupId>org.modelmapper</groupId>
            <artifactId>modelmapper</artifactId>
            <version>${modelmapper.version}</version>
        </dependency>

        <!-- Jackson -->


        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <scope>provided</scope>
        </dependency>

        <!-- JSON logging -->
        <dependency>
            <groupId>net.logstash.logback</groupId>
            <artifactId>logstash-logback-encoder</artifactId>
            <version>${logback.encoder.version}</version>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.codehaus.janino</groupId>
            <artifactId>janino</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
      
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Before After Spring Test Runner -->
        <dependency>
            <groupId>org.bitbucket.radistao.test</groupId>
            <artifactId>before-after-spring-test-runner</artifactId>
            <version>${springrunner.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-jdk8</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>com.microsoft.sqlserver</groupId>
            <artifactId>mssql-jdbc</artifactId>
            <version>13.2.1.jre11</version> 
        </dependency>
      
        <dependency>
            <groupId>org.yaml</groupId>
            <artifactId>snakeyaml</artifactId>
            <version>${snakeyaml.version}</version>
        </dependency>
  
    </dependencies>

    <build>
<!--        <finalName>${project.artifactId}</finalName>-->
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.projectlombok</groupId>
                    <artifactId>lombok-maven-plugin</artifactId>
                    <version>${lombok.version}</version>
                    <dependencies>
                        <dependency>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </dependency>
                    </dependencies>
                </plugin>
            </plugins>
        </pluginManagement>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-dependency-plugin</artifactId>
                <executions>
                    <execution>
                        <phase>install</phase>
                        <goals>
                            <goal>copy-dependencies</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>${project.build.directory}/lib</outputDirectory>
                            <excludeScope>provided</excludeScope>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-enforcer-plugin</artifactId>
                <executions>
                    <execution>
                        <id>enforce-maven</id>
                        <goals>
                            <goal>enforce</goal>
                        </goals>
                        <configuration>
                            <rules>
                                <requireMavenVersion>
                                    <version>3.3.9</version>
                                </requireMavenVersion>
                            </rules>
                        </configuration>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            <plugin>
                <groupId>io.github.git-commit-id</groupId>
                <artifactId>git-commit-id-maven-plugin</artifactId>
                <version>9.0.1</version>
                <executions>
                    <execution>
                        <id>get-the-git-infos</id>
                        <goals>
                            <goal>revision</goal>
                        </goals>
                        <phase>initialize</phase>
                    </execution>
                </executions>
                <configuration>
                    <dotGitDirectory>${project.basedir}/.git</dotGitDirectory>
                    <generateGitPropertiesFile>true</generateGitPropertiesFile>
                </configuration>
            </plugin>
            <!-- Below plugin ensures the execution of test cases during maven build-->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <executions>
                    <execution>
                        <id>integration-test</id>
                        <goals>
                            <goal>integration-test</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>verify</id>
                        <goals>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
                <configuration>
                    <skip>${failsafe.skip}</skip>
                </configuration>
            </plugin>

            <plugin>
			  <groupId>org.jacoco</groupId>
			  <artifactId>jacoco-maven-plugin</artifactId>
			  <version>${jacoco.version}</version>
			
			  <executions>
			    <execution>
			      <id>jacoco-prepare-agent</id>
			      <goals>
			        <goal>prepare-agent</goal>
			      </goals>
			      <configuration>
			        <destFile>${project.build.directory}/jacoco.exec</destFile>
			      </configuration>
			    </execution>
			
			    <execution>
			      <id>jacoco-report</id>
			      <phase>verify</phase>
			      <goals>
			        <goal>report</goal>
			      </goals>
			      <configuration>
			        <dataFile>${project.build.directory}/jacoco.exec</dataFile>
			      </configuration>
			    </execution>
			  </executions>
			</plugin>

        </plugins>
    </build>
</project>


/*
//***********************************************
// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/

package com.optum.fads.pgp.reportsection.api.controller;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import com.optum.fads.pgp.reportsection.api.common.ListTableParams;
import com.optum.fads.pgp.reportsection.api.common.ListTableParamsReq;
import com.optum.fads.pgp.reportsection.api.common.constants.ReportSectionConstants;
import com.optum.fads.pgp.reportsection.api.dto.AccessLevel;
import com.optum.fads.pgp.reportsection.api.dto.AppUser;
import com.optum.fads.pgp.reportsection.api.dto.BehaviorPatternDTO;
import com.optum.fads.pgp.reportsection.api.dto.PaginationResultRI;

import com.optum.fads.pgp.reportsection.api.dto.ReportItemDTO;
import com.optum.fads.pgp.reportsection.api.dto.Role;
import com.optum.fads.pgp.reportsection.api.exception.ReportSectionApiException;
import com.optum.fads.pgp.reportsection.api.service.IReportItemDataService;

/**
 * Use this class to add the methods so that a single web service can be used to
 * get and update the FADS Report Section data 
 *
 ** @author Anil Wagh
 */
@Component
@RestController
//@RequestMapping("/")
@CrossOrigin
public class ReportItemController {
	
	private static final Logger logit = LoggerFactory
			.getLogger(ReportItemController.class);
	@Autowired
	private IReportItemDataService iReportItemDataService;
	
	  final String[] DISALLOWED_FIELDS = new String[]{"listTableParams.selectedItemIds"};
	     
	    @InitBinder(value = "listTableParams")
	    void initListTableParamsValidator(WebDataBinder binder) {
	        binder.setDisallowedFields(DISALLOWED_FIELDS);
	    }
	    
	
	/**
	* this method will give the Report Item data records per page by filter/sort criteria
	 * 
	 * @param - ListTableParams (contains sort, filter conditions; page number, page size)
	 */
	@GetMapping(value = "/getreportitems/",headers="Accept=application/json")
	public ResponseEntity getReportItems(ListTableParamsReq listTableParamsReq,String searchInput) {
		PaginationResultRI paginationResult;
		try {
			ListTableParams listTableParams=new ListTableParams();
			listTableParams.setPageNumber(listTableParamsReq.getPageNumber());
			listTableParams.setRecordsPerPage(listTableParamsReq.getRecordsPerPage());
			listTableParams.setSearchBy(listTableParamsReq.getSearchBy());
			listTableParams.setSearchInput(Collections.singletonList(searchInput));
			listTableParams.setSelectedItemIds(listTableParamsReq.getSelectedItemIds());
			listTableParams.setSortBy(listTableParamsReq.getSortBy());
			listTableParams.setSortOrder(listTableParamsReq.getSortOrder());
			paginationResult = iReportItemDataService.getReportItemsList(listTableParams);	
		} catch (ReportSectionApiException ex) {
			logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
		}		
		return ResponseEntity
		        .status(HttpStatus.OK)                 
		        .body(paginationResult);
   }
	 /**
	  * this method will get the report item record corresponding to input Report Item ID  
	 * @param - Report Item ID 
	 */
	@GetMapping(value = "/getreportitemdetails/{reportItemId}")
	 public ResponseEntity getReportItemById(@PathVariable(name = "reportItemId") Integer reportItemId)
		 
	{   
		ReportItemDTO reportItemDTO = null;
		 try {	
			 reportItemDTO = iReportItemDataService.getReportItemById(reportItemId);
		 } catch (ReportSectionApiException ex) {
			 logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
				return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
	     }		
		return ResponseEntity
		            .status(HttpStatus.OK)                 
		            .body(reportItemDTO);
	 }
	 /**
	 * this method will delete the Report Item record corresponding to input Report Item ID  
	 * @param - Report Item ID 
	 */
	@DeleteMapping(value = "/deletereportitem/{reportitemid}")
	public ResponseEntity deleteReportItemById(@PathVariable(name = "reportitemid") Integer reportItemId)
 
	{   
		List<String> deleteReportItemMessages;
		 try {
			 deleteReportItemMessages = iReportItemDataService.deleteReportItem(reportItemId);
		 } catch (ReportSectionApiException ex) {
			 logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
				return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
	     }		
		return ResponseEntity
		       .status(HttpStatus.OK)                 
		       .body(deleteReportItemMessages);
	 }
	/**
	* this method will add a Report Item 
	 * 
	 * @param - reportItemDTO
	 */
	@PostMapping(value = {"/newreportitem"})
	public ResponseEntity newReportItem(@RequestBody ReportItemDTO reportItemDTO) {
		ReportItemDTO retReportItemDTO = null;
		String userAccess = "";
		boolean userHasAccess = false;
		try {
			DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(ReportSectionConstants.DATE_FORMAT_MMDDYYYY_HHMMSS_A,
				Locale.ENGLISH);
			Authentication auth =  SecurityContextHolder.getContext().getAuthentication();
			if (auth != null) {
				AppUser user = (AppUser) auth.getPrincipal();
				reportItemDTO.setCreatedBySystemId(user.getUserSystemId());
				reportItemDTO.setModifiedBySystemId(user.getUserSystemId());
				List<AccessLevel> userAccessLevels = user.getRole().getAllowedAccesses();
				for (AccessLevel userAccessLevel : userAccessLevels) {
					if (userAccessLevel.getModuleCode().equals("STUDY")) {
						userAccess = userAccessLevel.getAccess();
						break;
					}
				}
				if (userAccess.equals("A") || userAccess.equals("B")) {
					userHasAccess = true;
				}
			}
			if (userHasAccess) {
				LocalDateTime currentLocalDate = LocalDateTime.now(iReportItemDataService.getZoneId());
				// Save the create and update date as per local time zone in the DTO
				reportItemDTO.setCreatedDate(dateTimeFormatter.format(currentLocalDate));
				reportItemDTO.setModifiedDate(dateTimeFormatter.format(currentLocalDate));
				retReportItemDTO = iReportItemDataService.addReportItem(reportItemDTO);
				return ResponseEntity
				        .status(HttpStatus.CREATED)                 
				        .body(retReportItemDTO);
			} else {
				return new ResponseEntity<String>(ReportSectionConstants.NOT_AUTHORIZED, HttpStatus.FORBIDDEN);
			}
		} catch (ReportSectionApiException ex) {
			logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
		}		
		
   }
	/**
	* this method will update a report section 
	 * 
	 * @param - reportItemDTO
	 */
	@PutMapping(value = {"/updatereportitem/{reportItemId}"})
	public ResponseEntity<String> updateReportItem(@PathVariable Integer reportItemId, @RequestBody ReportItemDTO reportItemDTO) {
		String updReportItemMessage;
		String userAccess = "";
		boolean userHasAccess = false;
		try {
			DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(ReportSectionConstants.DATE_FORMAT_MMDDYYYY_HHMMSS_A,
				Locale.ENGLISH);
			Authentication auth =  SecurityContextHolder.getContext().getAuthentication();
			if (auth != null) {
				AppUser user = (AppUser) auth.getPrincipal();
				reportItemDTO.setModifiedBySystemId(user.getUserSystemId());
				List<AccessLevel> userAccessLevels = user.getRole().getAllowedAccesses();
				for (AccessLevel userAccessLevel : userAccessLevels) {
					if (userAccessLevel.getModuleCode().equals("STUDY")) {
						userAccess = userAccessLevel.getAccess();
						break;
					}
				}
				if (userAccess.equals("A") || 
						(userAccess.equals("B") && reportItemDTO.getCreatedBySystemId().equals(user.getUserSystemId()))) {
					userHasAccess = true;
				}
			}
			
			if (userHasAccess) {
					LocalDateTime currentLocalDate = LocalDateTime.now(iReportItemDataService.getZoneId());
					// Save the update date as per local time zone in the DTO
					reportItemDTO.setModifiedDate(dateTimeFormatter.format(currentLocalDate));
					updReportItemMessage = iReportItemDataService.updateReportItem(reportItemId, reportItemDTO);
					return ResponseEntity
					        .status(HttpStatus.OK)                 
					        .body(updReportItemMessage);
			} else {
				return new ResponseEntity<String>(ReportSectionConstants.NOT_AUTHORIZED, HttpStatus.FORBIDDEN);
			}
		} catch (com.optum.fads.pgp.reportsection.api.exception.ReportSectionApiException ex) {
			logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
		}		
		
   }
	/**
	* this method will get the available behavior pattern records  
	 * 
	 * @param - Report Item ID
	 */
	@GetMapping(value = {"/getavailablebehaviorpatterns/{reportItemId}"})
	public ResponseEntity getAvailableBehaviors(@PathVariable Integer reportItemId) {
		List<BehaviorPatternDTO> availableBehaviorPatternsList;
		try {
			availableBehaviorPatternsList = iReportItemDataService.getAvailableBehaviorPatterns(reportItemId);
		} catch (ReportSectionApiException ex) {
			logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
		}		
		return ResponseEntity
		        .status(HttpStatus.OK)                 
		        .body(availableBehaviorPatternsList);
   }
	/**
	* this method will get the selected behavior pattern records
	 * 
	 * @param - Report Item ID
	 */
	@GetMapping(value = {"/getselectedbehaviorpatterns/{reportItemId}"})
	public ResponseEntity getSelectedBehaviors(@PathVariable Integer reportItemId) {
		List<BehaviorPatternDTO> selectedBehaviorPatternsList;
		 try {
			 selectedBehaviorPatternsList = iReportItemDataService.getSelectedBehaviorPatterns(reportItemId);
		 } catch (ReportSectionApiException ex) {
			 logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
				return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
	     }		
		return ResponseEntity
		            .status(HttpStatus.OK)                 
		            .body(selectedBehaviorPatternsList);
   }
	/**
	 * this method will give all the Report Item data or records per page for My Items request
	 * 
	 * @param - ListTableParams (contains sort, filter conditions; page number, page
	 *          size)
	 */
	@GetMapping(value = { "/getmyreportitems/" }, headers = "Accept=application/json")
	public ResponseEntity getMyReportItems(ListTableParams listTableParams) {
		PaginationResultRI paginationResult;
		try {
			Authentication auth =  SecurityContextHolder.getContext().getAuthentication();
			if (auth != null) {
				AppUser user = (AppUser) auth.getPrincipal();
				if (listTableParams.getSearchBy() == null) {
					listTableParams.setSearchBy(new ArrayList <String>());
					listTableParams.setSearchInput(new ArrayList <String>());
				}
				listTableParams.getSearchBy().add(ReportSectionConstants.USER_SYSTEM_ID);
				listTableParams.getSearchInput().add(user.getUserSystemId());
			}
			paginationResult = iReportItemDataService.getReportItemsList(listTableParams);
		} catch (ReportSectionApiException ex) {
			logit.error(ReportSectionConstants.EXCEPTION_MESSAGE, ex.getMessage());
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(ReportSectionConstants.EXCEPTION_MESSAGE);
		}
		return ResponseEntity.status(HttpStatus.OK).body(paginationResult);
	}
}]


package com.optum.fads.pgp.reportsection.api.controller;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import com.optum.fads.pgp.reportsection.api.common.ListTableParams;
import com.optum.fads.pgp.reportsection.api.common.ListTableParamsReq;
import com.optum.fads.pgp.reportsection.api.common.constants.ReportSectionConstants;
import com.optum.fads.pgp.reportsection.api.dto.AccessLevel;
import com.optum.fads.pgp.reportsection.api.dto.AppUser;
import com.optum.fads.pgp.reportsection.api.dto.BehaviorPatternDTO;
import com.optum.fads.pgp.reportsection.api.dto.PaginationResultRI;
import com.optum.fads.pgp.reportsection.api.dto.ReportItemDTO;
import com.optum.fads.pgp.reportsection.api.dto.Role;
import com.optum.fads.pgp.reportsection.api.exception.ReportSectionApiException;
import com.optum.fads.pgp.reportsection.api.service.IReportItemDataService;

@RunWith(MockitoJUnitRunner.class)
public class ReportItemControllerTests {

    @InjectMocks
    private ReportItemController controller;

    @Mock
    private IReportItemDataService service;

    @Mock
    private SecurityContext securityContext;

    @Mock
    private Authentication authentication;

    private AppUser userWithA;     // access A
    private AppUser userWithB;     // access B
    private AppUser userWithC;     // no access

    @Before
    public void setup() {
        SecurityContextHolder.setContext(securityContext);

        // service zone id
        when(service.getZoneId()).thenReturn(ZoneId.systemDefault());

        userWithA = buildUser("U1", "A");
        userWithB = buildUser("U1", "B");
        userWithC = buildUser("U1", "C");
    }

    @After
    public void cleanup() {
        SecurityContextHolder.clearContext();
    }

    // ---------- helpers ----------
    private void mockAuth(AppUser user) {
        when(securityContext.getAuthentication()).thenReturn(authentication);
        when(authentication.getPrincipal()).thenReturn(user);
    }

    private AppUser buildUser(String systemId, String access) {
        AppUser u = mock(AppUser.class);
        when(u.getUserSystemId()).thenReturn(systemId);

        AccessLevel al = mock(AccessLevel.class);
        when(al.getModuleCode()).thenReturn("STUDY");
        when(al.getAccess()).thenReturn(access);

        Role role = mock(Role.class);
        when(role.getAllowedAccesses()).thenReturn(Collections.singletonList(al));

        when(u.getRole()).thenReturn(role);
        return u;
    }

    // ---------- getReportItems ----------
    @Test
    public void getReportItems_ok() {
        ListTableParamsReq req = new ListTableParamsReq();
        req.setPageNumber(1);
        req.setRecordsPerPage(10);
        req.setSearchBy(Arrays.asList("reportItemName"));
        req.setSelectedItemIds(Arrays.asList(1, 2));
        req.setSortBy("reportItemName");
        req.setSortOrder(1);

        PaginationResultRI pr = new PaginationResultRI();
        when(service.getReportItemsList(any(ListTableParams.class))).thenReturn(pr);

        ResponseEntity resp = controller.getReportItems(req, "opioids");

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        assertSame(pr, resp.getBody());

        // verify the controller built ListTableParams with singletonList(searchInput)
        verify(service).getReportItemsList(argThat(p ->
                p.getPageNumber() == 1 &&
                p.getRecordsPerPage() == 10 &&
                "reportItemName".equals(p.getSortBy()) &&
                p.getSortOrder() == 1 &&
                p.getSearchInput().equals(Collections.singletonList("opioids")) &&
                p.getSelectedItemIds().equals(Arrays.asList(1, 2))
        ));
    }

    @Test
    public void getReportItems_exception_returns400() {
        ListTableParamsReq req = new ListTableParamsReq();
        when(service.getReportItemsList(any(ListTableParams.class)))
                .thenThrow(new ReportSectionApiException("boom"));

        ResponseEntity resp = controller.getReportItems(req, "x");
        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }

    // ---------- getReportItemById ----------
    @Test
    public void getReportItemById_ok() {
        ReportItemDTO dto = new ReportItemDTO();
        dto.setReportItemId(10);

        when(service.getReportItemById(10)).thenReturn(dto);

        ResponseEntity resp = controller.getReportItemById(10);

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        ReportItemDTO body = (ReportItemDTO) resp.getBody();
        assertEquals(Integer.valueOf(10), body.getReportItemId());
    }

    @Test
    public void getReportItemById_exception_returns400() {
        when(service.getReportItemById(10)).thenThrow(new ReportSectionApiException("err"));

        ResponseEntity resp = controller.getReportItemById(10);

        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }

    // ---------- deleteReportItemById ----------
    @Test
    public void deleteReportItemById_ok() {
        List<String> msgs = Collections.singletonList("deleted");
        when(service.deleteReportItem(10)).thenReturn(msgs);

        ResponseEntity resp = controller.deleteReportItemById(10);

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        assertSame(msgs, resp.getBody());
    }

    @Test
    public void deleteReportItemById_exception_returns400() {
        when(service.deleteReportItem(10)).thenThrow(new ReportSectionApiException("err"));

        ResponseEntity resp = controller.deleteReportItemById(10);

        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }

    // ---------- newReportItem ----------
    @Test
    public void newReportItem_accessA_created() {
        mockAuth(userWithA);

        ReportItemDTO in = new ReportItemDTO();
        ReportItemDTO out = new ReportItemDTO();
        out.setReportItemId(999);

        when(service.addReportItem(any(ReportItemDTO.class))).thenReturn(out);

        ResponseEntity resp = controller.newReportItem(in);

        assertEquals(HttpStatus.CREATED.value(), resp.getStatusCodeValue());
        assertSame(out, resp.getBody());

        // verify fields set on DTO before calling service
        verify(service).addReportItem(argThat(dto ->
                "U1".equals(dto.getCreatedBySystemId()) &&
                "U1".equals(dto.getModifiedBySystemId()) &&
                dto.getCreatedDate() != null &&
                dto.getModifiedDate() != null
        ));
    }

    @Test
    public void newReportItem_accessB_created() {
        mockAuth(userWithB);

        ReportItemDTO in = new ReportItemDTO();
        when(service.addReportItem(any(ReportItemDTO.class))).thenReturn(new ReportItemDTO());

        ResponseEntity resp = controller.newReportItem(in);
        assertEquals(HttpStatus.CREATED.value(), resp.getStatusCodeValue());
    }

    @Test
    public void newReportItem_noAccess_forbidden() {
        mockAuth(userWithC);

        ResponseEntity resp = controller.newReportItem(new ReportItemDTO());

        assertEquals(HttpStatus.FORBIDDEN.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.NOT_AUTHORIZED, resp.getBody());

        verify(service, never()).addReportItem(any());
    }

    @Test
    public void newReportItem_exception_returns400() {
        mockAuth(userWithA);

        when(service.addReportItem(any())).thenThrow(new ReportSectionApiException("err"));

        ResponseEntity resp = controller.newReportItem(new ReportItemDTO());

        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }

    // ---------- updateReportItem ----------
    @Test
    public void updateReportItem_accessA_ok() {
        mockAuth(userWithA);

        ReportItemDTO dto = new ReportItemDTO();
        dto.setCreatedBySystemId("SOMEONE_ELSE"); // A can update anyone

        when(service.updateReportItem(eq(9), any(ReportItemDTO.class)))
                .thenReturn("updated");

        ResponseEntity<String> resp = controller.updateReportItem(9, dto);

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        assertEquals("updated", resp.getBody());

        verify(service).updateReportItem(eq(9), argThat(x ->
                "U1".equals(x.getModifiedBySystemId()) &&
                x.getModifiedDate() != null
        ));
    }

    @Test
    public void updateReportItem_accessB_owner_ok() {
        mockAuth(userWithB);

        ReportItemDTO dto = new ReportItemDTO();
        dto.setCreatedBySystemId("U1"); // owner

        when(service.updateReportItem(eq(9), any(ReportItemDTO.class)))
                .thenReturn("updated");

        ResponseEntity<String> resp = controller.updateReportItem(9, dto);

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        assertEquals("updated", resp.getBody());
    }

    @Test
    public void updateReportItem_accessB_notOwner_forbidden() {
        mockAuth(userWithB);

        ReportItemDTO dto = new ReportItemDTO();
        dto.setCreatedBySystemId("OTHER"); // not owner

        ResponseEntity<String> resp = controller.updateReportItem(9, dto);

        assertEquals(HttpStatus.FORBIDDEN.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.NOT_AUTHORIZED, resp.getBody());

        verify(service, never()).updateReportItem(anyInt(), any());
    }

    @Test
    public void updateReportItem_noAccess_forbidden() {
        mockAuth(userWithC);

        ResponseEntity<String> resp = controller.updateReportItem(9, new ReportItemDTO());

        assertEquals(HttpStatus.FORBIDDEN.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.NOT_AUTHORIZED, resp.getBody());
    }

    @Test
    public void updateReportItem_exception_returns400() {
        mockAuth(userWithA);

        when(service.updateReportItem(eq(9), any()))
                .thenThrow(new ReportSectionApiException("err"));

        ResponseEntity<String> resp = controller.updateReportItem(9, new ReportItemDTO());

        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }

    // ---------- getAvailableBehaviors ----------
    @Test
    public void getAvailableBehaviors_ok() {
        List<BehaviorPatternDTO> list = new ArrayList<>();
        list.add(new BehaviorPatternDTO());

        when(service.getAvailableBehaviorPatterns(7)).thenReturn(list);

        ResponseEntity resp = controller.getAvailableBehaviors(7);

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        assertSame(list, resp.getBody());
    }

    @Test
    public void getAvailableBehaviors_exception_returns400() {
        when(service.getAvailableBehaviorPatterns(7)).thenThrow(new ReportSectionApiException("err"));

        ResponseEntity resp = controller.getAvailableBehaviors(7);

        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }

    // ---------- getSelectedBehaviors ----------
    @Test
    public void getSelectedBehaviors_ok() {
        List<BehaviorPatternDTO> list = new ArrayList<>();
        list.add(new BehaviorPatternDTO());

        when(service.getSelectedBehaviorPatterns(7)).thenReturn(list);

        ResponseEntity resp = controller.getSelectedBehaviors(7);

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        assertSame(list, resp.getBody());
    }

    @Test
    public void getSelectedBehaviors_exception_returns400() {
        when(service.getSelectedBehaviorPatterns(7)).thenThrow(new ReportSectionApiException("err"));

        ResponseEntity resp = controller.getSelectedBehaviors(7);

        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }

    // ---------- getMyReportItems ----------
    @Test
    public void getMyReportItems_addsUserSystemIdFilter_ok() {
        mockAuth(userWithA);

        ListTableParams params = new ListTableParams();
        // simulate no searchBy
        params.setSearchBy(null);

        PaginationResultRI pr = new PaginationResultRI();
        when(service.getReportItemsList(any(ListTableParams.class))).thenReturn(pr);

        ResponseEntity resp = controller.getMyReportItems(params);

        assertEquals(HttpStatus.OK.value(), resp.getStatusCodeValue());
        assertSame(pr, resp.getBody());

        // confirm controller added filter
        assertNotNull(params.getSearchBy());
        assertNotNull(params.getSearchInput());
        assertTrue(params.getSearchBy().contains(ReportSectionConstants.USER_SYSTEM_ID));
        assertTrue(params.getSearchInput().contains("U1"));
    }

    @Test
    public void getMyReportItems_exception_returns400() {
        mockAuth(userWithA);

        when(service.getReportItemsList(any(ListTableParams.class)))
                .thenThrow(new ReportSectionApiException("err"));

        ResponseEntity resp = controller.getMyReportItems(new ListTableParams());

        assertEquals(HttpStatus.BAD_REQUEST.value(), resp.getStatusCodeValue());
        assertEquals(ReportSectionConstants.EXCEPTION_MESSAGE, resp.getBody());
    }
}
