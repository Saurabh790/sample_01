 Closing JPA EntityManager in OpenEntityManagerInViewInterceptor
2025-08-14 16:51:24 [http-nio-8080-exec-9] DEBUG o.s.web.servlet.DispatcherServlet - Failed to complete request: java.lang.ClassCastException: class java.lang.String cannot be cast to class com.optum.fads.pgp.datarules.dto.AppUser (java.lang.String is in module java.base of loader 'bootstrap'; com.optum.fads.pgp.datarules.dto.AppUser is in unnamed module of loader 'app')
2025-08-14 16:51:24 [http-nio-8080-exec-9] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [/fads] threw exception [Request processing failed: java.lang.ClassCastException: class java.lang.String cannot be cast to class com.optum.fads.pgp.datarules.dto.AppUser (java.lang.String is in module java.base of loader 'bootstrap'; com.optum.fads.pgp.datarules.dto.AppUser is in unnamed module of loader 'app')] with root cause
java.lang.ClassCastException: class java.lang.String cannot be cast to class com.optum.fads.pgp.datarules.dto.AppUser (java.lang.String is in module java.base of loader 'bootstrap'; com.optum.fads.pgp.datarules.dto.AppUser is in unnamed module of loader 'app')
	at com.optum.fads.pgp.study.controller.StudyController.createStudy(StudyController.java:172)
	
	
	
	/*
//***********************************************
	// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/

package com.optum.fads.pgp.study.controller;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.optum.fads.pgp.datarules.dto.AccessLevel;
import com.optum.fads.pgp.datarules.dto.AppUser;
import com.optum.fads.pgp.datarules.dto.Study;
import com.optum.fads.pgp.datarules.dto.StudyDTO;
import com.optum.fads.pgp.study.common.rest.ResponseBuilder;
import com.optum.fads.pgp.study.common.util.SortOrder;
import com.optum.fads.pgp.study.common.util.StudyConstants;
//import com.optum.fads.pgp.study.common.util.StudyDTOValidator;
import com.optum.fads.pgp.study.common.util.StudyEnum;
import com.optum.fads.pgp.study.common.util.StudySortEnum;
import com.optum.fads.pgp.study.exception.StudyNotFoundException;
import com.optum.fads.pgp.study.service.ICommonService;
import com.optum.fads.pgp.study.service.IStudyService;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
//import io.swagger.annotations.ApiOperation;
//import io.swagger.annotations.ApiParam;
import lombok.extern.slf4j.Slf4j;

/**
 * Example controller class containing routes for API business logic.
 *
 */
@RestController
@RequestMapping("/study")
@Slf4j
public class StudyController {

	private ResponseBuilder responseBuilder;

	@Autowired
	private final IStudyService studyService;
	@Autowired
	private ICommonService commonService;

	@Autowired
	public StudyController(ResponseBuilder responseBuilder, IStudyService studyService) {
		this.responseBuilder = responseBuilder;
		this.studyService = studyService;
	}

	/**
	 * Example GET API request
	 *
	 * @return HTTP status OK with greeting message
	 */
	@GetMapping(value = { "/findAll" }, headers = "Accept=application/json")
//	@ApiOperation(value = "findAll", notes = "This will provide all items based on filtering and sorting .")
	public Page<Study> findAll(
			@RequestParam(name = "sortBy", required = false, defaultValue = "studyName") StudyEnum sortBy,
			@RequestParam(name = "sortOrder", required = false, defaultValue = "desc") SortOrder sortOrder,
	//		@ApiParam(value = "Allowable values are :[studyName,createdBy,updatedBy]", allowableValues = "studyName,createdBy,updatedBy") 
			@RequestParam(value = "searchKeys", required = false) List<String> searchKeys,
			@RequestParam(value = "serchvalues", required = false) List<String> serchvalues)

	{
		Map<String, String> map = null;
		// String sort = StudySortEnum.valueOf(sortBy.label).value;
		String sortValue = StudySortEnum.valueOf(sortBy.name()).value;

		Pageable pageable = PageRequest.of(0, Integer.MAX_VALUE, Sort.by(Sort.Order.desc(sortValue).ignoreCase()));// )
																													// Sort.by(sortValue).descending());
		if (sortOrder.name().equalsIgnoreCase("asc")) {
			pageable = PageRequest.of(0, Integer.MAX_VALUE, Sort.by(Sort.Order.asc(sortValue).ignoreCase()));// Sort.by(sortValue).ascending());
		}
		if ((searchKeys != null) && (!searchKeys.isEmpty())) {
			map = IntStream.range(0, searchKeys.size()).boxed()
					.collect(Collectors.toMap(i -> searchKeys.get(i), i -> serchvalues.get(i)));
		}

		return studyService.findAllStudies(map, pageable);

	}

	/**
	 * Example GET API request
	 *
	 * @return HTTP status OK with greeting message
	 */
	@GetMapping(value = { "/findAllByPageable/" }, headers = "Accept=application/json")
//	@ApiOperation(value = "findAllByPageable", notes = "This will provide study items based on paging, filtering and sorting .")
	public Page<Study> findAllByPageable(
			@RequestParam(name = "pageNumber", required = true, defaultValue = "1") @Min(1) Integer pageNumber,
			@RequestParam(name = "recordsPerPage", required = true, defaultValue = "10") @Min(10) Integer recordsPerPage,
			@RequestParam(name = "sortBy", required = false, defaultValue = "studyName") StudyEnum sortBy,
			@RequestParam(name = "sortOrder", required = false, defaultValue = "desc") Integer sortOrder,
			@RequestParam(value = "searchBy", required = false) List<String> searchKeys,
			@RequestParam(value = "searchInput", required = false) String searchInput) {
		Map<String, String> map = null;

		String sortValue = StudySortEnum.valueOf(sortBy.name()).value;
		if (pageNumber > 0) {
			--pageNumber;
		} else {
			pageNumber = 0;
		}

		Pageable pageable = PageRequest.of(pageNumber, recordsPerPage,
				Sort.by(Sort.Order.desc(sortValue).ignoreCase()));
		if (SortOrder.valueOf(sortOrder).toString().equalsIgnoreCase("asc")) {
			pageable = PageRequest.of(pageNumber, recordsPerPage, Sort.by(Sort.Order.asc(sortValue).ignoreCase()));
		}

		if ((searchKeys != null) && (!searchKeys.isEmpty())) {
			List<String> serchvalues = Collections.singletonList(searchInput);
			map = IntStream.range(0, searchKeys.size()).boxed()
					.collect(Collectors.toMap(i -> searchKeys.get(i), i -> serchvalues.get(i)));
		}

		return studyService.findAllStudies(map, pageable);
	}

//	@ApiOperation("Retrieve a single study item based on ID")
	@GetMapping("study/{id}")
	public ResponseEntity<?> getStudy(
	//		@ApiParam(name = "id", value = "study id", required = true) 
			@PathVariable("id") Long id) {

		StudyDTO studyDTO = studyService.getStudy(id);
		if (null == studyDTO)
			throw new StudyNotFoundException(id);

		return new ResponseEntity<StudyDTO>(studyDTO, HttpStatus.OK);
	}

	@PostMapping("study")
	public ResponseEntity createStudy(@Valid @RequestBody StudyDTO study) {
//		if (errors.hasErrors()) {
//	        return new ResponseEntity(new ApiErrors(errors), HttpStatus.BAD_REQUEST);
//	    }
		StudyDTO studyDto = null;
		String userAccess = "";
		boolean userHasAccess = false;
		AppUser user = (AppUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		List<AccessLevel> userAccessLevels = user.getRole().getAllowedAccesses();
		for (AccessLevel userAccessLevel : userAccessLevels) {
			if (userAccessLevel.getModuleCode().equals("STUDY")) {
				userAccess = userAccessLevel.getAccess();
				break;
			}
		}
		if (userAccess.equals("A") || userAccess.equals("B")) {
			userHasAccess = true;
		}
		if (userHasAccess) {
			study.setCreatedBySystemId(user.getUserSystemId());
			study.setUpdatedBySystemId(user.getUserSystemId());
			study.setUser(user.getUserSystemId());
			study.getTimePeriods().forEach(tp -> {
				tp.setCreatedUser(user.getUserSystemId());
				tp.setUpdatedUser(user.getUserSystemId());
			});
			LocalDateTime currentLocalDate = LocalDateTime.now(commonService.getZoneId());
			study.setCreateDate(currentLocalDate);
			study.setUpdateDate(currentLocalDate);
			studyDto = studyService.createStudy(study);
			return new ResponseEntity<StudyDTO>(studyDto, HttpStatus.CREATED);
		} else {
			return new ResponseEntity<String>(StudyConstants.NOT_AUTHORIZED, HttpStatus.FORBIDDEN);
		}

	}

	@PutMapping("study/{id}")
	public ResponseEntity updateStudy(@PathVariable("id") int id, @RequestBody StudyDTO study) {
		String updStudyGroupMessage;
		String userAccess = "";
		boolean userHasAccess = false;
		StudyDTO b = null;
		AppUser user = (AppUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		study.setUser(user.getUserSystemId());		
		study.setUpdatedBySystemId(user.getUserSystemId());
		List<AccessLevel> userAccessLevels = user.getRole().getAllowedAccesses();
		for (AccessLevel userAccessLevel : userAccessLevels) {
			if (userAccessLevel.getModuleCode().equals("STUDY")) {
				userAccess = userAccessLevel.getAccess();
				break;
			}
		}
		if (userAccess.equals("A") || 
				(userAccess.equals("B") && study.getCreatedBySystemId().equals(user.getUserSystemId()))) {
			userHasAccess = true;
		}
		if (userHasAccess) {
			study.getTimePeriods().forEach(tp -> {
				tp.setCreatedUser(user.getUserSystemId());
				tp.setUpdatedUser(user.getUserSystemId());
			});
			
			LocalDateTime currentLocalDate = LocalDateTime.now(commonService.getZoneId());
			study.setUpdateDate(currentLocalDate);
			b = studyService.updateStudy(id, study);
			return new ResponseEntity<StudyDTO>(b, HttpStatus.OK);
		} else {
			return new ResponseEntity<String>(StudyConstants.NOT_AUTHORIZED, HttpStatus.FORBIDDEN);
		}
	}

	@DeleteMapping("study/{id}")
	public ResponseEntity deleteStudy(@PathVariable("id") long id) {
		String error = "";
		if(studyService.isJobsExistWithStudy(id)) {
			return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(StudyConstants.STUDY_JOB_EXIST);
		}
		
		boolean isDeleted = studyService.deleteStudy(id);
		if (isDeleted) {
			String responseContent = "Study has been deleted successfully";
			return new ResponseEntity(responseContent, HttpStatus.OK);
		}
		
		error = "Error while deleting study ";
		
		return new ResponseEntity<String>(error, HttpStatus.INTERNAL_SERVER_ERROR);
	}

	@PostMapping("scheduleStudy")
	public ResponseEntity<Study> scheduleStudy(@Valid @RequestBody Study study) {

		AppUser user = (AppUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
		study.setCreatedBySystemId(user.getUserSystemId());
		study.setUpdatedBySystemId(user.getUserSystemId());
		studyService.scheduleStudyJob(study);


		
		return new ResponseEntity<Study>(study, HttpStatus.OK);

	}

	/*
	 * @ResponseStatus(HttpStatus.BAD_REQUEST)
	 * 
	 * @ExceptionHandler(MethodArgumentNotValidException.class) public List<String>
	 * handleValidationExceptions(MethodArgumentNotValidException ex) { return
	 * ex.getBindingResult().getAllErrors().stream().map(ObjectError::
	 * getDefaultMessage) .collect(Collectors.toList()); }
	 */
//	@ApiOperation("Retrieve a single study item based on ID")
	@PostMapping("checkStudyName")
	public ResponseEntity<Boolean> checkStudyNameExists(@RequestBody Study study) {
		boolean exist = false;
		if(study!=null)
			exist=studyService.isStudyNameExists(study.getStudyName().trim().toLowerCase());
		

		return new ResponseEntity<Boolean>(exist, HttpStatus.OK);
	}
	/**
	 * this method will return all the Studies data or records per page for My Items request
	 *
	 * @return HTTP status OK with greeting message
	 */
	@GetMapping(value = { "/findMyStudiesByPageable/" }, headers = "Accept=application/json")
//	@ApiOperation(value = "findMyStudiesByPageable", notes = "This will provide study items based on paging, filtering and sorting .")
	public Page<Study> findMyStudiesByPageable(
			@RequestParam(name = "pageNumber", required = true, defaultValue = "1") @Min(1) Integer pageNumber,
			@RequestParam(name = "recordsPerPage", required = true, defaultValue = "10") @Min(10) Integer recordsPerPage,
			@RequestParam(name = "sortBy", required = false, defaultValue = "studyName") StudyEnum sortBy,
			@RequestParam(name = "sortOrder", required = false, defaultValue = "desc") Integer sortOrder,
			@RequestParam(value = "searchBy", required = false) List<String> searchKeys,
			@RequestParam(value = "searchInput", required = false) List<String> searchvalues) {
		Map<String, String> map = null;

		String sortValue = StudySortEnum.valueOf(sortBy.name()).value;
		if (pageNumber > 0) {
			--pageNumber;
		} else {
			pageNumber = 0;
		}

		Authentication auth =  SecurityContextHolder.getContext().getAuthentication();
		if (auth != null) {
			AppUser user = (AppUser) auth.getPrincipal();
			int myItemsIndex = searchvalues.indexOf(StudyConstants.USER_SYSTEM_ID);
			searchvalues.set(myItemsIndex, user.getUserSystemId());
		}
		
		Pageable pageable = PageRequest.of(pageNumber, recordsPerPage,
				Sort.by(Sort.Order.desc(sortValue).ignoreCase()));
		if (SortOrder.valueOf(sortOrder).toString().equalsIgnoreCase("asc")) {
			pageable = PageRequest.of(pageNumber, recordsPerPage, Sort.by(Sort.Order.asc(sortValue).ignoreCase()));
		}

		if ((searchKeys != null) && (!searchKeys.isEmpty())) {
			map = IntStream.range(0, searchKeys.size()).boxed()
					.collect(Collectors.toMap(i -> searchKeys.get(i), i -> searchvalues.get(i)));
		}

		return studyService.findAllStudies(map, pageable);
	}
}





getting issue in above class at every line 

		AppUser user = (AppUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
