UserRolesController.java
package com.optum.fads.userroles.api.controllers;

import com.optum.fads.userroles.api.dto.UserListItem;
import com.optum.fads.userroles.api.service.UserService;
import org.springframework.data.domain.*;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@RestController
@RequestMapping("/api/userroles")
public class UserRolesController {

    /**
     * API field name -> entity path (whitelist).
     * Use ONLY these keys in sortBy/searchBy.
     */
    private static final Map<String, String> FIELD_MAP;
    static {
        Map<String, String> m = new LinkedHashMap<>();
        m.put("uiSystemId", "uiSystemId");
        m.put("uiUserId",   "uiUserId");
        m.put("lastName",   "uiLastName");
        m.put("firstName",  "uiFirstName");
        m.put("title",      "uiTitle");
        m.put("email",      "uiEMailAddress");
        m.put("fadsGrpName","seUsrGrp.fadsGrp.fadsGrpName");
        m.put("surGrpName", "seUsrGrp.fadsSurGrp.surGrpName");
        m.put("caseGrpName","seUsrGrp.fadsCaseGrp.caseGrpName");
        FIELD_MAP = Collections.unmodifiableMap(m);
    }

    private final UserService userService;
    public UserRolesController(UserService userService) {
        this.userService = userService;
    }

    /**
     * Working endpoint path (with your server context "/userroles"):
     * http://localhost:8080/userroles/api/userroles/findAllByPageable
     *
     * Examples:
     *  - Pagination only:
     *    ?pageNumber=1&recordsPerPage=10
     *
     *  - Sort (1=ASC, 0=DESC). Multi-sort supported:
     *    ?sortBy=lastName,firstName&sortOrder=0,1
     *
     *  - Filters (contains, case-insensitive). Multiple allowed:
     *    ?searchBy=lastName&searchBy=fadsGrpName&searchInput=Gupta&searchInput=Admin
     */
    @GetMapping(value = "/findAllByPageable", headers = "Accept=application/json")
    public Page<UserListItem> findAllByPageable(
            @RequestParam(name = "pageNumber",     defaultValue = "1")  Integer pageNumber,
            @RequestParam(name = "recordsPerPage", defaultValue = "10") Integer recordsPerPage,
            @RequestParam(name = "sortBy",         defaultValue = "lastName") String sortByCsv,
            @RequestParam(name = "sortOrder",      defaultValue = "1")  String sortOrderCsv,
            @RequestParam(name = "searchBy",       required = false) List<String> searchBy,
            @RequestParam(name = "searchInput",    required = false) List<String> searchInput
    ) {
        // --- page index (user gives 1-based) ---
        int pageIdx = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;

        // --- build Sort ---
        List<String> sortByList = Arrays.stream(sortByCsv.split(","))
                .map(String::trim).filter(s -> !s.isBlank()).toList();

        List<Integer> orderList = Arrays.stream(sortOrderCsv.split(","))
                .map(String::trim).filter(s -> !s.isBlank())
                .map(v -> "1".equals(v) ? 1 : 0).toList();

        // pad sort orders to match sort fields
        List<Integer> paddedOrders = new ArrayList<>(orderList);
        while (paddedOrders.size() < sortByList.size()) {
            paddedOrders.add(paddedOrders.isEmpty() ? 1 : paddedOrders.get(paddedOrders.size() - 1));
        }

        List<Sort.Order> orders = new ArrayList<>();
        for (int i = 0; i < sortByList.size(); i++) {
            String apiField = sortByList.get(i);
            String entityPath = FIELD_MAP.get(apiField); // whitelist
            if (entityPath != null) {
                boolean asc = paddedOrders.get(i) == 1;
                // IMPORTANT: removed .ignoreCase() to avoid SQL Server DISTINCT/ORDER BY conflict
                orders.add(asc ? Sort.Order.asc(entityPath) : Sort.Order.desc(entityPath));
            }
        }
        if (orders.isEmpty()) {
            orders.add(Sort.Order.asc(FIELD_MAP.get("lastName")));
        }

        Pageable pageable = PageRequest.of(pageIdx, recordsPerPage, Sort.by(orders));

        // --- build filters map (searchBy[i] -> searchInput[i]) ---
        Map<String, String> filters = Collections.emptyMap();
        if (searchBy != null && searchInput != null && !searchBy.isEmpty() && !searchInput.isEmpty()) {
            int size = Math.min(searchBy.size(), searchInput.size());
            filters = IntStream.range(0, size).boxed().collect(Collectors.toMap(
                    i -> searchBy.get(i),
                    i -> searchInput.get(i),
                    (a, b) -> b,
                    LinkedHashMap::new));
        }

        return userService.getUsers(filters, pageable, FIELD_MAP);
    }
}

UserSpecification.java
package com.optum.fads.userroles.api.spec;

import com.optum.fads.userroles.api.domain.UiUserBase;
import jakarta.persistence.criteria.*;
import org.springframework.data.jpa.domain.Specification;

import java.util.*;

public final class UserSpecification {

    private UserSpecification() {}

    /**
     * Builds an AND of case-insensitive CONTAINS filters for provided fields.
     * DISTINCT is enabled only if any filter touches a joined (nested) path.
     */
    public static Specification<UiUserBase> containsAll(
            Map<String, String> filters,
            Map<String, String> fieldMap
    ) {
        if (filters == null || filters.isEmpty()) {
            return null; // no predicates
        }

        return (root, query, cb) -> {
            // DISTINCT only when a nested path (dot) implies joins
            boolean needsDistinct = filters.keySet().stream()
                    .map(fieldMap::get)
                    .filter(Objects::nonNull)
                    .anyMatch(path -> path.contains("."));
            if (needsDistinct) {
                query.distinct(true);
            }

            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, String> e : filters.entrySet()) {
                String apiField = e.getKey();
                String value    = e.getValue();
                if (value == null || value.isBlank()) continue;

                String entityPath = fieldMap.get(apiField);
                if (entityPath == null) continue; // ignore unknown field

                Expression<String> pathExpr = resolvePath(root, entityPath);
                predicates.add(cb.like(cb.lower(pathExpr), "%" + value.toLowerCase(Locale.ROOT) + "%"));
            }

            return predicates.isEmpty()
                    ? cb.conjunction()
                    : cb.and(predicates.toArray(new Predicate[0]));
        };
    }

    /**
     * Resolve dot-separated path, creating LEFT joins for intermediate segments.
     * Example: "seUsrGrp.fadsGrp.fadsGrpName"
     */
    @SuppressWarnings("unchecked")
    private static Expression<String> resolvePath(From<?, ?> root, String dotPath) {
        String[] parts = dotPath.split("\\.");
        From<?, ?> from = root;
        Path<?> path = root;

        for (int i = 0; i < parts.length; i++) {
            String part = parts[i];

            if (i < parts.length - 1) {
                // intermediate: join if not already joined
                from = safeJoin(from, part);
                path = from;
            } else {
                // leaf: attribute
                path = path.get(part);
            }
        }
        return (Expression<String>) path.as(String.class);
    }

    private static From<?, ?> safeJoin(From<?, ?> from, String attribute) {
        for (Join<?, ?> j : from.getJoins()) {
            if (j.getAttribute() != null && attribute.equals(j.getAttribute().getName())) {
                return (From<?, ?>) j;
            }
        }
        return from.join(attribute, JoinType.LEFT);
    }
}


<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
