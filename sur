/*
//***********************************************
// Copyright UNITEDHEALTH GROUP CORPORATION 2018.
// This software and documentation contain confidential and
// proprietary information owned by UnitedHealth Group Corporation.
// Unauthorized use and distribution are prohibited.
//***********************************************
*/
/**
 * The service contains methods to retrieve and update FADS jobs data.
 *
 * @author Anil Wagh
 */
package com.optum.fads.pgp.jobs.api.service.impl;

import com.optum.fads.pgp.jobs.api.common.FadsConfigProperties;
import com.optum.fads.pgp.jobs.api.common.JobDatesEnum;
import com.optum.fads.pgp.jobs.api.common.JobsConstants;
import com.optum.fads.pgp.jobs.api.common.ListTableParams;
import com.optum.fads.pgp.jobs.api.domain.FadsConfigT;
import com.optum.fads.pgp.jobs.api.dto.JobDTO;
import com.optum.fads.pgp.jobs.api.dto.PaginationResult;
import com.optum.fads.pgp.jobs.api.exception.JobsMonitorApiException;
import com.optum.fads.pgp.jobs.api.mapper.JobDetailMapper;
import com.optum.fads.pgp.jobs.api.repo.FadsConfigRepository;
import com.optum.fads.pgp.jobs.api.service.IJobMonitorDataService;
import com.optum.fads.pgp.jobs.api.service.util.ServiceUtil;
import com.optum.fads.pgp.jobs.api.snowflakeDomain.JobLuStatusT;
import com.optum.fads.pgp.jobs.api.snowflakeDomain.JobMasterCasesT;
import com.optum.fads.pgp.jobs.api.snowflakeDomain.JobMasterLogsT;
import com.optum.fads.pgp.jobs.api.snowflakeDomain.JobMasterT;
import com.optum.fads.pgp.jobs.api.snowflakeRepo.JobMasterSchedulerRepository;
import com.optum.fads.pgp.jobs.api.snowflakeRepo.JobsRepository;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.text.SimpleDateFormat;
import java.time.LocalDateTime;
import java.util.*;

@Service("jobMonitorDataService")
@Slf4j
public class JobMonitorDataService implements IJobMonitorDataService {

    private static final Logger logit = LoggerFactory.getLogger(JobMonitorDataService.class);


    @Autowired
    private FadsConfigRepository fadsConfigRepository;

    @Autowired
    private JobsRepository jobsRepository;

    @Autowired
    private JobMasterSchedulerRepository jobMasterSchedulerRepository;

    @Autowired
    private JobDetailMapper jobDetailMapper;


    /**
     * this method will give all the jobs records data or records per page
     *
     * Parameters - ListTableParams (contains sort, filter conditions; page number, page size)
     */
    @Transactional(readOnly = true)
    public PaginationResult getJobsByListTableParms(ListTableParams listTableParams) {
        Long jobsCount;
        List<JobMasterT> jobsList;
        List<JobDTO> jobsDataList = null;
        PaginationResult paginationResult = new PaginationResult();
        Pageable pageable = null;
        try {
            if (listTableParams.getSearchBy() == null) {
                pageable = createPageable(listTableParams);
                Page<JobMasterT> page = jobsRepository.findAll(pageable);
                paginationResult = new PaginationResult();
                jobsDataList =jobDetailMapper.convertToJobDTOs( page.getContent());// populateJobDataList(jobsList);

                paginationResult.setJobsData(jobsDataList);
                paginationResult.setTotalRecordsCount(Long.valueOf(page.getTotalElements()).intValue());
            } else {
                paginationResult = getJobsOnSearchCriteria(listTableParams);
            }
        } catch (Exception e) {
            throw new JobsMonitorApiException(JobsConstants.EXCEPTION_MESSAGE, e);
        }
        return paginationResult;
    }

    	@Transactional(readOnly = true)
//	@Override
    public JobDTO getJobDetailsById(Integer jobMasterRecId) {
        logit.info(" Obtain job data  for the ID = {}", jobMasterRecId);
        JobDTO jobDTO = null;
        try {
            Optional<JobMasterT> optional = jobsRepository.findById(jobMasterRecId);
            if (optional.isPresent()) {
                JobMasterT jobInd = optional.get();
                jobDTO = jobDetailMapper.convertToJob(optional.get());

                logit.info(" Job DTO populated with data for the ID = {}", jobMasterRecId);
                List<JobMasterLogsT> jobMasterLogs = jobInd.getJobMasterLogsTs();// jobsRepository.loadLogFileNotes(jobMasterRecId);
                if (!jobMasterLogs.isEmpty()) {
                    populateNotes(jobDTO, jobMasterLogs);
                }
            } else {
                logit.info("No data obtained for the Job ID = {}", jobMasterRecId);
                throw new JobsMonitorApiException(JobsConstants.JOB_ID_DOES_NOT_EXIST);
            }
        } catch (Exception e) {
            throw new JobsMonitorApiException(e.getMessage());
        }
        return jobDTO;
    }

    /**
     * this method will cancel job
     *
     * Job cannot be cancelled if it is already complete, failed,  cancelled or scheduled for purge
     *
     * Parameters - jobDTO
     */

    public String cancelJob(JobDTO jobDTO) {
        String status = null;
        int jobId = jobDTO.getJobId();
        Date currentDate = Calendar.getInstance().getTime();
        logit.info(" Call to cancel a Job Id = {}", jobId);
        try {
            Optional<JobMasterT> optional = jobsRepository.findById(jobId);
            JobMasterT jobMasterT = optional.get();
            if (jobMasterT != null) {
                jobMasterSchedulerRepository.deleteById(jobId);
                JobLuStatusT jobLuStatusT = new JobLuStatusT();
                jobLuStatusT.setStatusCd(JobsConstants.JOB_STATUS_CANCELLED);
                jobMasterT.setJobLuStatusT(jobLuStatusT);

                jobMasterT.setUpdatedByUserId(jobDTO.getModifiedBy());
                jobMasterT.setUpdateDte(currentDate);
                jobMasterT = jobsRepository.saveAndFlush(jobMasterT);
                status = JobsConstants.JOB_CANCELED;
            }
        } catch (Exception e) {
            throw new JobsMonitorApiException(JobsConstants.EXCEPTION_MESSAGE, e);
        }
        return status;
    }

    /**
     * this method will purge job
     *
     * Job cannot be purged if it's case count > 0 or Scheduled for Purging (15), Job Stage # Complete (7,8,9,10,11,12),
     *		project Study Submitted (1)	or Project Snapshot Completed (6)
     *
     * Parameters - jobDTO
     */
    public String purgeJob(JobDTO jobDTO) {
        String status;
        int updateStatus = 0;
        int jobId = jobDTO.getJobId();
        Date currentDate = Calendar.getInstance().getTime();
        logit.info("Started JobMonitorDataService : purgeJob()");
        try {
            int purgeFlag = JobsConstants.PURGE_FLAG_TRUE;
            JobLuStatusT jobLuStatusT = new JobLuStatusT();
            jobLuStatusT.setStatusCd(JobsConstants.JOB_STATUS_SCH_4_PURGE);
            updateStatus = jobsRepository.updatePurgeFlag(jobLuStatusT, jobDTO.getJobId(), purgeFlag, jobDTO.getUpdatedBySystemId(), currentDate);
            if (updateStatus == 1) {
                status = JobsConstants.JOB_PURGED;
            } else {
                status = JobsConstants.PURGE_JOB_INVALID_DATA;
            }
        } catch (Exception e) {
            throw new JobsMonitorApiException(e);
        }
        logit.info("Completed JobMonitorDataService : purgeJob()");
        return status;
    }

    public String changeDatesById(Integer jobMasterRecId) {
        String changeJobDatesCheck = JobsConstants.CHANGE_DATES_INVALID_REQUEST;
        try {
            Optional<JobMasterT> optional = jobsRepository.findById(jobMasterRecId);
            if (optional.isPresent()) {
                JobMasterT jobMasterT = optional.get();
                switch (jobMasterT.getJobLuStatusT().getStatusCd()) {
                    case 1:    // Project Study Submitted
                    case 3:
                        logit.info("Job ID {} with status = {} for new Run Date",
                                jobMasterRecId, jobMasterT.getJobLuStatusT().getStatusCd());
                        changeJobDatesCheck = JobsConstants.SET_RUN_DATE;    // new run date
                        break;
                    case 20:    // JOB_STATUS_COMPLETE
                        logit.info("Job ID {} with status = {} for new Purge Date",
                                jobMasterRecId, jobMasterT.getJobLuStatusT().getStatusCd());
                        changeJobDatesCheck = JobsConstants.SET_PURGE_DATE;    // new purge date
                        break;
                    default:
                        break;
                }
            } else {
                changeJobDatesCheck = JobsConstants.JOB_ID_DOES_NOT_EXIST;
            }
        } catch (Exception e) {
            throw new JobsMonitorApiException(JobsConstants.EXCEPTION_MESSAGE, e);
        }
        return changeJobDatesCheck;
    }

    /**
     * this method will change the scheduled date for the job
     *
     * It can be changed only for job status 1 (Study Submitted) or 3 (Waiting for stage 1 or 2 to begin)
     *
     * Parameters - jobDTO : Job Id, User ID, input schedule date as ~ 03-23-2021T01:15:00TAM
     */
    public String changeScheduleDateById(JobDTO jobDTO) {
        int jobStatus;
        String status;
        int updateStatus = 0;
        logit.info("Job ID {} change to new Run Date {}", jobDTO.getJobId(), jobDTO.getScheduledRunDate());
        try {
            jobStatus = jobDTO.getStatus();
            logit.info("Job ID {} with status = {} change to new Run Date",
                    jobDTO.getJobId(), jobDTO.getStatus());
          //  JobMasterT jobMasterT = jobDetailMapper.convertToJobMasterT(jobDTO);// convertToJobMasterT(jobDTO);
            logit.info("Job ID {} change scheduled Run Date to {}", jobDTO.getJobId(), jobDTO.getScheduledRunDate());

            updateStatus = jobsRepository.updateScheduledRunDate(jobDTO.getJobId(), jobDTO.getScheduledRunDate(), jobDTO.getUpdatedBySystemId(), LocalDateTime.now());

          status = JobsConstants.RUN_DATE_SAVED;
        } catch (Exception e) {
            throw new JobsMonitorApiException(JobsConstants.EXCEPTION_MESSAGE, e);
        }
        return status;
    }


    /**
     * this method will change the purge date for the job
     *
     * It can be changed only for job status 20 (Completed)
     *
     * Parameters - jobDTO : Job Id, User ID, input schedule date as ~ 03-23-2021
     */
    public String changePurgeDateById(JobDTO jobDTO) {
        logit.info("Started JobMonitorDataService : changePurgeDateById()");
        String status;
        Date currentDate = Calendar.getInstance().getTime();
        int updateStatus = 0;
        SimpleDateFormat sdf = new SimpleDateFormat(JobsConstants.DATE_FORMAT_MMDDYYYY);
        Integer jobMasterRecId = jobDTO.getJobId();
        try {
            logit.info("Job ID {} status = {} for new Purge Date {}",
                    jobMasterRecId, jobDTO.getStatus(), jobDTO.getPurgeDate());
         //   Date purgeDate = sdf.parse(jobDTO.getPurgeDate());
            updateStatus = jobsRepository.updatePurgeDate(jobMasterRecId, jobDTO.getPurgeDate(), jobDTO.getUpdatedBySystemId(), currentDate);
            if (updateStatus == 1) {
                status = JobsConstants.PURGE_DATE_SAVED;
            } else {
                status = JobsConstants.PURGE_JOB_INVALID_DATA;
            }

        } catch (Exception e) {
            throw new JobsMonitorApiException(JobsConstants.EXCEPTION_MESSAGE, e);
        }
        logit.info("Completed JobMonitorDataService : changePurgeDateById()");
        return status;
    }

    public PaginationResult getJobsOnSearchCriteria(ListTableParams listTableParams) {
        Pageable pageable = null;
        String studyNameVal = JobsConstants.PERCENT_STR;
        String jobStatusVal = JobsConstants.PERCENT_STR;
        String createdByVal = JobsConstants.PERCENT_STR;
        String userIdVal = JobsConstants.PERCENT_STR;
        String searchInput;
        String searchBy;
        int jobIdValInt = 0;
        int jobsCount;
        int myItemsIndex = -1;
        int searchCritSize = 0;
        boolean spChInJobName = false;
        boolean jobIdSelected = false;
        List<JobDTO> jobsDataList;
        List<JobMasterT> jobsList = null;
        List<JobMasterT> jobsCntList = null;
        PaginationResult paginationResult = new PaginationResult();
        pageable = createPageable(listTableParams);
        if (listTableParams.getSearchBy().contains(JobsConstants.USER_SYSTEM_ID)) {
            myItemsIndex = listTableParams.getSearchBy().indexOf(JobsConstants.USER_SYSTEM_ID);
        }
        searchCritSize = listTableParams.getSearchBy().size();

        for (int index = 0; index < searchCritSize; index++) {
            searchInput = listTableParams.getSearchInput().get(index).toLowerCase();
            searchBy = listTableParams.getSearchBy().get(index);
            switch (searchBy) {
                case JobsConstants.JOB_STATUS_DESC:
                    jobStatusVal = JobsConstants.PERCENT_STR + searchInput + JobsConstants.PERCENT_STR;
                    break;
                case JobsConstants.STUDY_NAME:
                    if (StringUtils.containsAny(searchInput, JobsConstants.PERCENT_CHAR)
                            || StringUtils.containsAny(searchInput, JobsConstants.UNDERSCORE_CHAR)) {
                        spChInJobName = true;
                    }
                    studyNameVal = ServiceUtil.replStudyName(searchInput);
                    break;
                case JobsConstants.CREATED_BY:
                    if (StringUtils.containsWhitespace(searchInput)) {
                        searchInput = searchInput.trim();
                        searchInput = searchInput.replaceAll("\\s+", " ");
                    }
                    createdByVal = JobsConstants.PERCENT_STR + searchInput + JobsConstants.PERCENT_STR;
                    break;
                case JobsConstants.USER_SYSTEM_ID:
                    userIdVal = searchInput;
                    break;
                case JobsConstants.JOB_ID:
					try {
						jobIdValInt = Integer.parseInt(searchInput);
					} catch (Exception e) {
						// if getting issue while parsing , returning to default value
					} 
                    jobIdSelected = true;
                    break;
                default:
                    break;
            }
        }

        if (jobIdSelected) {    // Only one record will be retrieved for a job ID
            if (myItemsIndex >= 0) {        // Retrieve my items
                jobsList = jobsRepository.getMyJobsBySearchCriteriaWithJobId(jobStatusVal, studyNameVal, createdByVal, userIdVal, jobIdValInt, pageable);
            } else {
                jobsList = jobsRepository.getJobsBySearchCriteriaWithJobId(jobStatusVal, studyNameVal, createdByVal, jobIdValInt, pageable);
            }
            jobsCntList = jobsList;
        } else if (spChInJobName) {
            if (myItemsIndex >= 0) {        // Retrieve my items
                jobsCntList = jobsRepository.getMyJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, userIdVal, null);
                jobsList = jobsRepository.getMyJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, userIdVal, pageable);
            } else {
                jobsCntList = jobsRepository.getJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, null);
                jobsList = jobsRepository.getJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, pageable);
            }
        } else {
            if (myItemsIndex >= 0) {        // Retrieve my items
                jobsCntList = jobsRepository.getMyJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, userIdVal, null);
                jobsList = jobsRepository.getMyJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, userIdVal, pageable);
            } else {
                jobsCntList = jobsRepository.getJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, null);
                jobsList = jobsRepository.getJobsBySearchCriteria(jobStatusVal, studyNameVal, createdByVal, pageable);
            }
        }
        jobsCount = jobsCntList.size();
        logit.info("jobs List size {}", jobsCount);
        if (!jobsList.isEmpty()) {
            jobsDataList = jobDetailMapper.convertToJobDTOs(jobsList);//populateJobDataList(jobsList);
            if (listTableParams.getSortBy().equals(JobsConstants.CASE_COUNT)) {
                if (listTableParams.getSortOrder() > 0) {
                    jobsDataList.sort(Comparator.comparing(JobDTO::getCaseCount));
                } else {
                    jobsDataList.sort(Comparator.comparing(JobDTO::getCaseCount).reversed());
                }
            }
            paginationResult.setJobsData(jobsDataList);
            paginationResult.setTotalRecordsCount(jobsCount);
        } else {
            paginationResult.setJobsData(new ArrayList<>());
            paginationResult.setTotalRecordsCount(jobsList.size());
        }
        return paginationResult;
    }

    private Pageable createPageable(ListTableParams listTableParams) {
        Pageable pageable = null;
        String sortStr1;
        String sortStr2 = "";
        String sortByStr = listTableParams.getSortBy();
        int pageNumberI = listTableParams.getPageNumber() - 1;
        int pageSizeI = listTableParams.getRecordsPerPage();
        //Pageable represents the Page configuration with sorting
        Sort.Order order1 = null;
        Sort.Direction sortDirection;
        Sort sort1;
        if (listTableParams.getSortOrder() > 0) {
            sortDirection = Sort.Direction.ASC;
        } else {
            sortDirection = Sort.Direction.DESC;
        }
        switch (sortByStr) {
            case JobsConstants.CASE_COUNT:
            case JobsConstants.STUDY_NAME:
                sortStr1 = "pbName";
                order1 = new Sort.Order(sortDirection, sortStr1).ignoreCase();
                sort1 = Sort.by(order1);
                break;
            case JobsConstants.JOB_STATUS_DESC:
                sortStr1 = "jobLuStatusT.statusDesc";
                order1 = new Sort.Order(sortDirection, sortStr1);
                sort1 = Sort.by(order1);
                break;
            case JobsConstants.SCHEDULED_RUN_DATE: 
            	sortStr1 = JobsConstants.DATE_SCHEDULED;
            	order1 = new Sort.Order(sortDirection, sortStr1);
                sort1 = Sort.by(order1);
                break;
            case JobsConstants.PURGE_DATE:
            	sortStr1 = JobsConstants.DATE_PURGE;
            	order1 = new Sort.Order(sortDirection, sortStr1);
                sort1 = Sort.by(order1);
                break;
            case JobsConstants.JOB_ID:
                sortStr1 = sortByStr;
                order1 = new Sort.Order(sortDirection, sortStr1);
                sort1 = Sort.by(order1);
                break;
            case JobsConstants.CREATED_BY:
                sortStr1 = "createUserName";
                order1 = new Sort.Order(sortDirection, sortStr1).ignoreCase();
                sort1 = Sort.by(order1);
                break;
            default:
                sortStr1 = JobsConstants.JOB_ID;
                order1 = new Sort.Order(sortDirection, sortStr1);
                sort1 = Sort.by(order1);
                break;
        }
        pageable = PageRequest.of(pageNumberI, pageSizeI, sort1);

        return pageable;
    }


    private void populateNotes(JobDTO jobDTO, List<JobMasterLogsT> jobMasterLogs) {
        List<String> notes = new ArrayList<>();
        for (JobMasterLogsT jobLog : jobMasterLogs) {
            if (Objects.nonNull(jobLog)) {
                notes.add(jobLog.getLogFileNotes());
            }
        }
        jobDTO.setNotes(notes);
        logit.info("Job log notes obtained for the ID = {}", jobDTO.getJobId());
    }



    private String formatStrDate(Date dt, JobDatesEnum jobDatesEnum) {
        String retDate = null;
        if (dt == null) {
            return null;
        }
        SimpleDateFormat dateTimeSecondsformatter = new SimpleDateFormat(JobsConstants.DATE_FORMAT_MMDDYYYY_HHMMSS_A);
        SimpleDateFormat dateTimeMinutesformatter = new SimpleDateFormat(JobsConstants.DATE_FORMAT_MMDDYYYY_HHMM_A);
        SimpleDateFormat shortDateFormat = new SimpleDateFormat(JobsConstants.DATE_FORMAT_MMDDYYYY);
        switch (jobDatesEnum) {
            case dateWoTime:
                retDate = shortDateFormat.format(dt);
                break;
            case dateTimeSeconds:
                retDate = dateTimeSecondsformatter.format(dt);
                break;
            case dateTimeMinutes:
                retDate = dateTimeMinutesformatter.format(dt);
                break;
            default:
                retDate = dateTimeMinutesformatter.format(dt);
        }
        return retDate;
    }
    /*

    public LocalDateTime convertToLocalDateTimeViaInstant(Date dateToConvert) {
        return dateToConvert.toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDateTime();
    }*/

    private Date formatDate(String dtStr, int dateFormat) {
        Date retDate;
        Date currentDate = Calendar.getInstance().getTime();
        SimpleDateFormat longDateFormat = new SimpleDateFormat(JobsConstants.DATE_FORMAT_MMDDYYYY_HHMMSS_A);
        SimpleDateFormat minDateFormat = new SimpleDateFormat(JobsConstants.DATE_FORMAT_MMDDYYYY_HHMM_A);
        SimpleDateFormat shortDateFormat = new SimpleDateFormat(JobsConstants.DATE_FORMAT_MMDDYYYY);
        if (dtStr == null) {
            retDate = currentDate;
        } else {
            try {
                switch (dateFormat) {
                    case 0:
                        retDate = shortDateFormat.parse(dtStr);
                        break;
                    case 1:
                        retDate = minDateFormat.parse(dtStr);
                        break;
                    case 2:
                        retDate = longDateFormat.parse(dtStr);
                        break;
                    default:
                        retDate = currentDate;
                }
            } catch (Exception e) {
                throw new JobsMonitorApiException(JobsConstants.EXCEPTION_MESSAGE, e);
            }
        }
        return retDate;
    }

    private Integer formatRowItem(Integer itemIntr) {
        if (itemIntr == null) {
            return JobsConstants.ZERO_VALUE;
        }
        return itemIntr;
    }

    @Override
    @Transactional
    public String getReportUrlByOptionCd(long optionCd) {
        String reportURL = "";
        Optional<FadsConfigT> optional = fadsConfigRepository.findById(JobsConstants.COGNOS_REPORT_OPTION_CODE);
        if (optional.isPresent()) {
            FadsConfigT fadsConfig = optional.get();
            reportURL = fadsConfig.getDescription();
        }
        logit.info("Cognos report URL = {}", reportURL);
        return reportURL;
    }

    public List<String> getCasesDetailsByJobId(Integer jobId) {
        JobMasterT jobById = jobsRepository.getJobById(jobId);
        List<JobMasterCasesT> cases = jobById.getJobMasterCasesTs();
        List<String> caseIds = new ArrayList<>();
        Iterator<JobMasterCasesT> caseIterator = cases.iterator();
        while (caseIterator.hasNext()) {
            JobMasterCasesT obj = caseIterator.next();
            caseIds.add(ServiceUtil.createCaseId(obj.getCaPrmNodeCd(), obj.getCaScndNodeCd(), obj.getCaSequenceId(), obj.getCaYearId()));
        }
        return caseIds;
    }

    @Override
    @Transactional
    public List<FadsConfigProperties> getFadsConfigByIds(List<Long> cd) {
        List<FadsConfigT> optional = fadsConfigRepository.findAllById(cd);
        List<FadsConfigProperties> configObjects = new ArrayList<>();
            for (FadsConfigT fadsConfig : optional) {
                FadsConfigProperties obj = new FadsConfigProperties();
                obj.setCode(fadsConfig.getOptionCode());
                obj.setDesc(fadsConfig.getDescription());
                obj.setValue(fadsConfig.getOptionValue());
                configObjects.add(obj);
            }
        return configObjects;
    }
}
