1) Controller
package com.optum.fads.userroles.api.controllers;

import com.optum.fads.userroles.api.dto.UserListItem;
import com.optum.fads.userroles.api.service.UserService;
import org.springframework.data.domain.*;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@RestController
@RequestMapping("/api/userroles")
public class UserRolesController {

    /**
     * Public API field name -> Entity path (whitelist)
     * Used for BOTH sorting and filtering safely.
     */
    private static final Map<String, String> FIELD_MAP;
    static {
        Map<String, String> m = new LinkedHashMap<>();
        m.put("uiSystemId", "uiSystemId");
        m.put("uiUserId",   "uiUserId");
        m.put("lastName",   "uiLastName");
        m.put("firstName",  "uiFirstName");
        m.put("title",      "uiTitle");
        m.put("email",      "uiEMailAddress");
        m.put("fadsGrpName","seUsrGrp.fadsGrp.fadsGrpName");
        m.put("surGrpName", "seUsrGrp.fadsSurGrp.surGrpName");
        m.put("caseGrpName","seUsrGrp.fadsCaseGrp.caseGrpName");
        FIELD_MAP = Collections.unmodifiableMap(m);
    }

    private final UserService userService;

    public UserRolesController(UserService userService) {
        this.userService = userService;
    }

    /**
     * Example:
     * /api/userroles/findAllByPageable?pageNumber=1&recordsPerPage=10&sortBy=lastName,firstName&sortOrder=1,1
     * Filtering (contains/ignore-case):
     * &searchBy=firstName,lastName&searchInput=jo,do
     *
     * sortOrder: 1 = ASC, 0 = DESC
     */
    @GetMapping(value = "/findAllByPageable", headers = "Accept=application/json")
    public Page<UserListItem> findAllByPageable(
            @RequestParam(name = "pageNumber",     defaultValue = "1")  Integer pageNumber,
            @RequestParam(name = "recordsPerPage", defaultValue = "10") Integer recordsPerPage,
            @RequestParam(name = "sortBy",         defaultValue = "lastName") String sortByCsv,
            @RequestParam(name = "sortOrder",      defaultValue = "1")  String sortOrderCsv,
            @RequestParam(name = "searchBy",       required = false) List<String> searchBy,
            @RequestParam(name = "searchInput",    required = false) List<String> searchInput
    ) {
        int pageIdx = (pageNumber != null && pageNumber > 0) ? pageNumber - 1 : 0;

        // ---------- SORT ----------
        List<String> sortByList = Arrays.stream(sortByCsv.split(","))
                .map(String::trim).filter(s -> !s.isBlank()).toList();

        List<Integer> orderList = Arrays.stream(sortOrderCsv.split(","))
                .map(String::trim).filter(s -> !s.isBlank())
                .map(v -> "1".equals(v) ? 1 : 0).toList();

        // Pad sort orders to match fields length
        List<Integer> paddedOrders = new ArrayList<>(orderList);
        while (paddedOrders.size() < sortByList.size()) {
            paddedOrders.add(paddedOrders.isEmpty() ? 1 : paddedOrders.get(paddedOrders.size() - 1));
        }

        List<Sort.Order> orders = new ArrayList<>();
        for (int i = 0; i < sortByList.size(); i++) {
            String apiField = sortByList.get(i);
            String entityPath = FIELD_MAP.get(apiField);
            if (entityPath != null) {
                boolean asc = paddedOrders.get(i) == 1;
                orders.add(asc
                        ? Sort.Order.asc(entityPath).ignoreCase()
                        : Sort.Order.desc(entityPath).ignoreCase());
            }
        }
        if (orders.isEmpty()) {
            orders.add(Sort.Order.asc(FIELD_MAP.get("lastName")).ignoreCase());
        }
        Pageable pageable = PageRequest.of(pageIdx, recordsPerPage, Sort.by(orders));

        // ---------- FILTERS (contains, case-insensitive) ----------
        Map<String, String> filters = Collections.emptyMap();
        if (searchBy != null && searchInput != null && !searchBy.isEmpty() && !searchInput.isEmpty()) {
            int size = Math.min(searchBy.size(), searchInput.size());
            filters = IntStream.range(0, size).boxed()
                    .collect(Collectors.toMap(
                            i -> searchBy.get(i),      // API field
                            i -> searchInput.get(i),   // value
                            (a, b) -> b,
                            LinkedHashMap::new));
        }

        return userService.getUsers(filters, pageable, FIELD_MAP);
    }
}

2) Service API
package com.optum.fads.userroles.api.service;

import com.optum.fads.userroles.api.dto.UserListItem;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.Map;

public interface UserService {
    Page<UserListItem> getUsers(Map<String, String> filters, Pageable pageable, Map<String, String> fieldMap);
}

3) Service Implementation
package com.optum.fads.userroles.api.service;

import com.optum.fads.userroles.api.domain.UiUserBase;
import com.optum.fads.userroles.api.dto.UserListItem;
import com.optum.fads.userroles.api.mapper.UserListItemMapper;
import com.optum.fads.userroles.api.repo.UiUserBaseRepository;
import com.optum.fads.userroles.api.spec.UserSpecification;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.util.Map;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UiUserBaseRepository repo;
    private final UserListItemMapper mapper;

    @Override
    public Page<UserListItem> getUsers(Map<String, String> filters, Pageable pageable, Map<String, String> fieldMap) {
        Specification<UiUserBase> spec = UserSpecification.containsAll(filters, fieldMap);
        return repo.findAll(spec, pageable).map(mapper::toDto);
    }
}

4) Repository
package com.optum.fads.userroles.api.repo;

import com.optum.fads.userroles.api.domain.UiUserBase;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface UiUserBaseRepository extends JpaRepository<UiUserBase, String>,
                                              JpaSpecificationExecutor<UiUserBase> {
}


Optional optimization (later): create a custom finder with @EntityGraph(attributePaths = {"seUsrGrp", "seUsrGrp.fadsGrp", "seUsrGrp.fadsSurGrp", "seUsrGrp.fadsCaseGrp"}) if you see N+1 while sorting/filtering by nested fields.

5) Specification (contains + ignore-case, supports nested paths)
package com.optum.fads.userroles.api.spec;

import com.optum.fads.userroles.api.domain.UiUserBase;
import jakarta.persistence.criteria.*;
import org.springframework.data.jpa.domain.Specification;

import java.util.*;

public final class UserSpecification {

    private UserSpecification() {}

    /**
     * AND all filters using case-insensitive CONTAINS.
     * filters keys are API field names; they're mapped to entity paths by fieldMap.
     */
    public static Specification<UiUserBase> containsAll(Map<String, String> filters, Map<String, String> fieldMap) {
        if (filters == null || filters.isEmpty()) {
            return null; // no filters
        }

        return (root, query, cb) -> {
            query.distinct(true);
            List<Predicate> predicates = new ArrayList<>();

            for (Map.Entry<String, String> e : filters.entrySet()) {
                String apiField = e.getKey();
                String value = e.getValue();
                if (value == null || value.isBlank()) continue;

                String entityPath = fieldMap.get(apiField);
                if (entityPath == null) continue;

                Expression<String> pathExpr = resolvePath(root, entityPath);
                Predicate p = cb.like(cb.lower(pathExpr), "%" + value.toLowerCase(Locale.ROOT) + "%");
                predicates.add(p);
            }

            return predicates.isEmpty() ? cb.conjunction() : cb.and(predicates.toArray(new Predicate[0]));
        };
    }

    /**
     * Resolve dot-separated path including LEFT joins (e.g., "seUsrGrp.fadsGrp.fadsGrpName").
     */
    @SuppressWarnings("unchecked")
    private static Expression<String> resolvePath(From<?, ?> root, String dotPath) {
        String[] parts = dotPath.split("\\.");
        From<?, ?> currentFrom = root;
        Path<?> currentPath = root;

        for (int i = 0; i < parts.length; i++) {
            String part = parts[i];

            if (i < parts.length - 1) {
                // intermediate segment — try to join
                currentFrom = safeJoin(currentFrom, part);
                currentPath = currentFrom;
            } else {
                // last segment — attribute
                currentPath = currentPath.get(part);
            }
        }

        return (Expression<String>) currentPath.as(String.class);
    }

    private static From<?, ?> safeJoin(From<?, ?> from, String attribute) {
        // avoid duplicate joins for the same attribute name
        for (Join<?, ?> join : from.getJoins()) {
            if (join.getAttribute() != null && attribute.equals(join.getAttribute().getName())) {
                return (From<?, ?>) join;
            }
        }
        return from.join(attribute, JoinType.LEFT);
    }
}

6) Mapper (same as you had)
package com.optum.fads.userroles.api.mapper;

import com.optum.fads.userroles.api.domain.UiUserBase;
import com.optum.fads.userroles.api.dto.UserListItem;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface UserListItemMapper {

    @Mapping(target = "lastName",   source = "uiLastName")
    @Mapping(target = "firstName",  source = "uiFirstName")
    @Mapping(target = "title",      source = "uiTitle")
    @Mapping(target = "email",      source = "uiEMailAddress")
    @Mapping(target = "fadsGrpName", source = "seUsrGrp.fadsGrp.fadsGrpName")
    @Mapping(target = "surGrpName",  source = "seUsrGrp.fadsSurGrp.surGrpName")
    @Mapping(target = "caseGrpName", source = "seUsrGrp.fadsCaseGrp.caseGrpName")
    UserListItem toDto(UiUserBase entity);
}

7) DTO (unchanged, shown for completeness)
package com.optum.fads.userroles.api.dto;

public class UserListItem {
    private final String uiSystemId;
    private final String uiUserId;
    private final String lastName;
    private final String firstName;
    private final String title;
    private final String email;
    private final String fadsGrpName;
    private final String surGrpName;
    private final String caseGrpName;

    public UserListItem(String uiSystemId, String uiUserId, String lastName, String firstName,
                        String title, String email, String fadsGrpName, String surGrpName, String caseGrpName) {
        this.uiSystemId = uiSystemId;
        this.uiUserId = uiUserId;
        this.lastName = lastName;
        this.firstName = firstName;
        this.title = title;
        this.email = email;
        this.fadsGrpName = fadsGrpName;
        this.surGrpName = surGrpName;
        this.caseGrpName = caseGrpName;
    }

    public String getUiSystemId() { return uiSystemId; }
    public String getUiUserId() { return uiUserId; }
    public String getLastName() { return lastName; }
    public String getFirstName() { return firstName; }
    public String getTitle() { return title; }
    public String getEmail() { return email; }
    public String getFadsGrpName() { return fadsGrpName; }
    public String getSurGrpName() { return surGrpName; }
    public String getCaseGrpName() { return caseGrpName; }
}
