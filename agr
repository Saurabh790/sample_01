GET http://localhost:8080/userroles/api/getUserList


Got it.
You want this flow:

Repository â†’ returns Entities (no JPQL in DAO)
Service â†’ uses MapStruct â†’ convert Entity â†’ DTO
Controller â†’ returns DTO List

âœ… Step 1: Create Repository (no custom query)
package com.optum.fads.userroles.api.repo;

import com.optum.fads.userroles.api.domain.UiUserBase;
import org.springframework.data.jpa.repository.JpaRepository;

public interface UiUserBaseRepository extends JpaRepository<UiUserBase, String> {
}


This gives you findAll() automatically.

âœ… Step 2: MapStruct Mapper
package com.optum.fads.userroles.api.mapper;

import com.optum.fads.userroles.api.domain.UiUserBase;
import com.optum.fads.userroles.api.dto.UserListItem;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface UserListItemMapper {

    @Mapping(source = "uiSystemId", target = "uiSystemId")
    @Mapping(source = "uiUserId", target = "uiUserId")
    @Mapping(source = "uiLastName", target = "uiLastName")
    @Mapping(source = "uiFirstName", target = "uiFirstName")
    @Mapping(source = "uiTitle", target = "uiTitle")
    @Mapping(source = "uiEMailAddress", target = "uiEMailAddress")
    @Mapping(source = "seUsrGrp.fadsGrp.fadsGrpName",   target = "fadsGrpName")
    @Mapping(source = "seUsrGrp.fadsSurGrp.surGrpName", target = "surGrpName")
    @Mapping(source = "seUsrGrp.fadsCaseGrp.caseGrpName", target = "caseGrpName")
    UserListItem toDto(UiUserBase entity);
}


ðŸ’¡ This flattens nested fields exactly like your SQL did.

âœ… Step 3: Service Layer
package com.optum.fads.userroles.api.service;

import com.optum.fads.userroles.api.dto.UserListItem;
import com.optum.fads.userroles.api.mapper.UserListItemMapper;
import com.optum.fads.userroles.api.repo.UiUserBaseRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final UiUserBaseRepository repo;
    private final UserListItemMapper mapper;

    @Override
    public List<UserListItem> getUserList() {
        return repo.findAll()
                .stream()
                .map(mapper::toDto)
                .toList();
    }
}

âœ… Step 4: Controller (fix constructor!)
@RestController
@RequiredArgsConstructor
public class UserRolesController {

    private final UserService userService;

    @GetMapping("/api/getUserList")
    public List<UserListItem> getUserList() {
        return userService.getUserList();
    }
}

âœ… Thatâ€™s it â€” No JPQL. No manual queries. Only Mapper.
âš  Important Note

If your DB contains many records, this approach loads all and then maps â†’ might cause N+1 query problem due to lazy joins.
But functionally, this works exactly how you asked: pure MapStruct, no query code.
