set JAVA_TOOL_OPTIONS=--add-opens=java.base/java.nio=org.apache.arrow.memory.core,ALL-UNNAMED
mvn spring-boot:run

SELECT CT_BATCH_ID, COUNT(*) AS row_count
FROM CA_UNIVERSE_BATCH_T
WHERE REC_MATCH_IND IS NULL
GROUP BY CT_BATCH_ID
ORDER BY CT_BATCH_ID;
2) Batches with no duplicates (inside SQL Server)
Duplicates are same HDR_CLM_TCN + LI_NUM within the batch.

sql

SELECT CT_BATCH_ID
FROM CA_UNIVERSE_BATCH_T
GROUP BY CT_BATCH_ID
HAVING SUM(CASE WHEN CNT > 1 THEN 1 ELSE 0 END) = 0;

-- with the duplication check
WITH d AS (
  SELECT CT_BATCH_ID, HDR_CLM_TCN, LI_NUM, COUNT(*) AS CNT
  FROM CA_UNIVERSE_BATCH_T
  GROUP BY CT_BATCH_ID, HDR_CLM_TCN, LI_NUM
)
SELECT CT_BATCH_ID
FROM d
GROUP BY CT_BATCH_ID
HAVING SUM(CASE WHEN CNT > 1 THEN 1 ELSE 0 END) = 0;
3) Batches already marked invalid
sql

SELECT CT_BATCH_ID,
       SUM(CASE WHEN REC_MATCH_IND = 'N' THEN 1 ELSE 0 END) AS invalid_rows,
       SUM(CASE WHEN REC_MATCH_IND = 'D' THEN 1 ELSE 0 END) AS dup_rows,
       SUM(CASE WHEN REC_MATCH_IND = 'Y' THEN 1 ELSE 0 END) AS valid_rows
FROM CA_UNIVERSE_BATCH_T
GROUP BY CT_BATCH_ID
ORDER BY CT_BATCH_ID;
4) Best “clean” candidates in SQL Server
This gives batches that are pending and have no duplicates inside the batch:

sql

WITH d AS (
  SELECT CT_BATCH_ID, HDR_CLM_TCN, LI_NUM, COUNT(*) AS CNT
  FROM CA_UNIVERSE_BATCH_T
  WHERE REC_MATCH_IND IS NULL
  GROUP BY CT_BATCH_ID, HDR_CLM_TCN, LI_NUM
)
SELECT CT_BATCH_ID
FROM d
GROUP BY CT_BATCH_ID
HAVING SUM(CASE WHEN CNT > 1 THEN 1 ELSE 0 END) = 0
ORDER BY CT_BATCH_ID;
5) Full validation (needs Snowflake)
The code also validates that each row exists in Snowflake DM_CLAIM_DRUG_T and matches participant.
So even if SQL Server looks clean, Snowflake can still reject it.

If you want, I can give a Snowflake query to validate a batch id once you tell me:

your Snowflake DB/schema
whether you can query CA_UNIVERSE_BATCH_T from Snowflake (or I should export keys).
Tell me which batch id you want to validate and I’ll give exact Snowflake validation SQL.
