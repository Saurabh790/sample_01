<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.7.18</version>
    <relativePath/>
  </parent>

  <groupId>com.optum.fads</groupId>
  <artifactId>case-entrybatch-poc</artifactId>
  <version>1.0.0-SNAPSHOT</version>

  <properties>
    <java.version>17</java.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-batch</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <scope>runtime</scope>
    </dependency>

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
      </plugin>
    </plugins>
  </build>
</project>


spring:
  datasource:
    url: jdbc:h2:mem:batchdb;DB_CLOSE_DELAY=-1
    driverClassName: org.h2.Driver
    username: sa
    password:

  sql:
    init:
      mode: always

  h2:
    console:
      enabled: true
      path: /h2-console

  batch:
    jdbc:
      initialize-schema: always
    job:
      enabled: true

logging:
  file:
    name: logs/invoice-batch.log
  level:
    root: INFO
    com.optum.fads: DEBUG
    org.springframework.batch: INFO




DROP TABLE IF EXISTS TXN_SOURCE;
DROP TABLE IF EXISTS CUSTOMER;
DROP TABLE IF EXISTS PRODUCT;
DROP TABLE IF EXISTS TXN_STAGE;
DROP TABLE IF EXISTS FINAL_TXN_LINE;
DROP TABLE IF EXISTS INVOICE_FINAL;
DROP TABLE IF EXISTS TXN_ERROR;

CREATE TABLE CUSTOMER (
  customer_id VARCHAR(20) PRIMARY KEY,
  discount_rate DECIMAL(5,2) NOT NULL
);

CREATE TABLE PRODUCT (
  product_id VARCHAR(20) PRIMARY KEY,
  tax_rate DECIMAL(5,2) NOT NULL
);

-- status: N=new, D=done, E=error
CREATE TABLE TXN_SOURCE (
  txn_id BIGINT PRIMARY KEY,
  customer_id VARCHAR(20),
  product_id VARCHAR(20),
  txn_amount DECIMAL(18,2),
  txn_time TIMESTAMP NOT NULL,
  currency VARCHAR(10) NOT NULL,
  channel VARCHAR(10) NOT NULL,
  invoice_date DATE NOT NULL,
  status CHAR(1) DEFAULT 'N' NOT NULL,
  run_id VARCHAR(80)
);

CREATE INDEX IDX_TXN_SOURCE_DATE_STATUS ON TXN_SOURCE(invoice_date, status);

-- persistent staging (audit of GOOD rows)
CREATE TABLE TXN_STAGE (
  stage_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  run_id VARCHAR(80) NOT NULL,
  invoice_date DATE NOT NULL,
  txn_id BIGINT NOT NULL,
  customer_id VARCHAR(20) NOT NULL,
  product_id VARCHAR(20) NOT NULL,
  base_amount DECIMAL(18,2) NOT NULL,
  discount_rate DECIMAL(5,2) NOT NULL,
  tax_rate DECIMAL(5,2) NOT NULL,
  discount DECIMAL(18,2) NOT NULL,
  tax DECIMAL(18,2) NOT NULL,
  commission DECIMAL(18,2) NOT NULL,
  net_amount DECIMAL(18,2) NOT NULL,
  created_at TIMESTAMP NOT NULL
);

CREATE UNIQUE INDEX UX_STAGE_RUN_TXN ON TXN_STAGE(run_id, txn_id);

CREATE TABLE TXN_ERROR (
  error_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  run_id VARCHAR(80) NOT NULL,
  invoice_date DATE NOT NULL,
  txn_id BIGINT NOT NULL,
  customer_id VARCHAR(20),
  product_id VARCHAR(20),
  txn_amount DECIMAL(18,2),
  error_reason VARCHAR(300) NOT NULL,
  created_at TIMESTAMP NOT NULL
);

-- final per-transaction computed output
CREATE TABLE FINAL_TXN_LINE (
  txn_id BIGINT PRIMARY KEY,
  run_id VARCHAR(80) NOT NULL,
  invoice_date DATE NOT NULL,
  customer_id VARCHAR(20) NOT NULL,
  base_amount DECIMAL(18,2) NOT NULL,
  discount DECIMAL(18,2) NOT NULL,
  tax DECIMAL(18,2) NOT NULL,
  commission DECIMAL(18,2) NOT NULL,
  net_amount DECIMAL(18,2) NOT NULL,
  created_at TIMESTAMP NOT NULL
);

CREATE INDEX IDX_FINAL_RUN ON FINAL_TXN_LINE(run_id);

-- aggregated invoice per customer/day
CREATE TABLE INVOICE_FINAL (
  invoice_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  run_id VARCHAR(80) NOT NULL,
  customer_id VARCHAR(20) NOT NULL,
  invoice_date DATE NOT NULL,
  total_gross DECIMAL(18,2) NOT NULL,
  total_discount DECIMAL(18,2) NOT NULL,
  total_tax DECIMAL(18,2) NOT NULL,
  total_commission DECIMAL(18,2) NOT NULL,
  total_net DECIMAL(18,2) NOT NULL,
  created_at TIMESTAMP NOT NULL
);

CREATE INDEX IDX_INVOICE_RUN ON INVOICE_FINAL(run_id);



package com.optum.fads.caseentrybatch.poc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InvoiceBatchApplication {
  public static void main(String[] args) {
    SpringApplication.run(InvoiceBatchApplication.class, args);
  }
}



package com.optum.fads.caseentrybatch.poc.data;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.sql.Date;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Random;

@Component
@Order(Integer.MIN_VALUE)
public class DataSeeder implements ApplicationRunner {
  private static final Logger log = LoggerFactory.getLogger(DataSeeder.class);
  private final JdbcTemplate jdbc;

  public DataSeeder(JdbcTemplate jdbc) {
    this.jdbc = jdbc;
  }

  @Override
  public void run(ApplicationArguments args) {
    Integer existing = jdbc.queryForObject("SELECT COUNT(*) FROM TXN_SOURCE", Integer.class);
    if (existing != null && existing > 0) {
      log.info("DataSeeder: TXN_SOURCE already has {} rows, skipping seed.", existing);
      return;
    }

    LocalDate invoiceDate = LocalDate.of(2026, 1, 24);

    for (int i = 1; i <= 10; i++) {
      String c = String.format("C%02d", i);
      BigDecimal discount = (i <= 3) ? new BigDecimal("0.10") : new BigDecimal("0.00");
      jdbc.update("INSERT INTO CUSTOMER(customer_id, discount_rate) VALUES (?,?)", c, discount);
    }

    for (int i = 1; i <= 5; i++) {
      String p = String.format("P%02d", i);
      jdbc.update("INSERT INTO PRODUCT(product_id, tax_rate) VALUES (?,?)", p, new BigDecimal("0.18"));
    }

    Random r = new Random(42);
    LocalDateTime baseTime = invoiceDate.atTime(9, 0);

    for (int i = 1; i <= 100; i++) {
      long txnId = 1000L + i;
      String customer = String.format("C%02d", 1 + r.nextInt(10));
      String product  = String.format("P%02d", 1 + r.nextInt(5));
      BigDecimal amount = new BigDecimal(50 + r.nextInt(500)).setScale(2);
      LocalDateTime t = baseTime.plusMinutes(i);

      jdbc.update(
          "INSERT INTO TXN_SOURCE(txn_id, customer_id, product_id, txn_amount, txn_time, currency, channel, invoice_date, status) " +
              "VALUES (?,?,?,?,?,?,?,?, 'N')",
          txnId, customer, product, amount,
          Timestamp.valueOf(t), "INR", (i % 2 == 0 ? "APP" : "WEB"), Date.valueOf(invoiceDate)
      );
    }

    jdbc.update("UPDATE TXN_SOURCE SET customer_id='C99' WHERE txn_id=1005"); // bad customer
    jdbc.update("UPDATE TXN_SOURCE SET product_id='PX' WHERE txn_id=1010");  // bad product
    jdbc.update("UPDATE TXN_SOURCE SET txn_amount=-10.00 WHERE txn_id=1020"); // negative
    jdbc.update("UPDATE TXN_SOURCE SET txn_amount=NULL WHERE txn_id=1030");   // null

    Integer count = jdbc.queryForObject("SELECT COUNT(*) FROM TXN_SOURCE", Integer.class);
    log.info("DataSeeder: Inserted {} TXN_SOURCE rows for invoice_date={}", count, invoiceDate);
  }
}



package com.optum.fads.caseentrybatch.poc.batch;

import java.math.BigDecimal;
import java.time.LocalDate;

public class TxnSourceRow {
  public long txnId;
  public String customerId;
  public String productId;
  public BigDecimal txnAmount;
  public LocalDate invoiceDate;

  // Enriched from joins
  public BigDecimal discountRate; // nullable
  public BigDecimal taxRate;      // nullable
}


package com.optum.fads.caseentrybatch.poc.batch;

import java.math.BigDecimal;
import java.time.LocalDate;

public class ProcessedTxn {
  public enum Kind { GOOD, ERROR }

  public Kind kind;

  public String runId;
  public long txnId;
  public String customerId;
  public String productId;
  public LocalDate invoiceDate;

  public BigDecimal baseAmount;

  // GOOD fields
  public BigDecimal discountRate;
  public BigDecimal taxRate;
  public BigDecimal discount;
  public BigDecimal tax;
  public BigDecimal commission;
  public BigDecimal netAmount;

  // ERROR fields
  public String errorReason;

  public static ProcessedTxn error(String runId, TxnSourceRow row, String reason) {
    ProcessedTxn p = new ProcessedTxn();
    p.kind = Kind.ERROR;
    p.runId = runId;
    p.txnId = row.txnId;
    p.customerId = row.customerId;
    p.productId = row.productId;
    p.invoiceDate = row.invoiceDate;
    p.baseAmount = row.txnAmount;
    p.errorReason = reason;
    return p;
  }

  public static ProcessedTxn good(String runId, TxnSourceRow row,
                                  BigDecimal discount, BigDecimal tax,
                                  BigDecimal commission, BigDecimal net) {
    ProcessedTxn p = new ProcessedTxn();
    p.kind = Kind.GOOD;
    p.runId = runId;
    p.txnId = row.txnId;
    p.customerId = row.customerId;
    p.productId = row.productId;
    p.invoiceDate = row.invoiceDate;
    p.baseAmount = row.txnAmount;
    p.discountRate = row.discountRate;
    p.taxRate = row.taxRate;
    p.discount = discount;
    p.tax = tax;
    p.commission = commission;
    p.netAmount = net;
    return p;
  }
}


package com.optum.fads.caseentrybatch.poc.batch;

import java.math.BigDecimal;
import java.time.LocalDate;

public class InvoiceSummary {
  public String runId;
  public String customerId;
  public LocalDate invoiceDate;

  public BigDecimal totalGross;
  public BigDecimal totalDiscount;
  public BigDecimal totalTax;
  public BigDecimal totalCommission;
  public BigDecimal totalNet;
}


package com.optum.fads.caseentrybatch.poc.batch;

import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.JobParametersIncrementer;
import org.springframework.batch.core.launch.support.RunIdIncrementer;

import java.time.LocalDateTime;

public class RunIdIncrementerWithRunId implements JobParametersIncrementer {
  private final RunIdIncrementer delegate = new RunIdIncrementer();

  @Override
  public JobParameters getNext(JobParameters parameters) {
    JobParameters next = delegate.getNext(parameters);

    String invoiceDate = (parameters == null) ? null : parameters.getString("invoiceDate");
    if (invoiceDate == null || invoiceDate.isBlank()) {
      invoiceDate = "2026-01-24"; // default for demo
    }

    String runId = "RUN_" + invoiceDate + "_" + LocalDateTime.now().toString();

    return new JobParametersBuilder(next)
        .addString("invoiceDate", invoiceDate, true)
        .addString("runId", runId, true)
        .toJobParameters();
  }
}


package com.optum.fads.caseentrybatch.poc.batch;

import org.springframework.batch.item.database.JdbcPagingItemReader;
import org.springframework.batch.item.database.Order;
import org.springframework.batch.item.database.support.H2PagingQueryProvider;
import org.springframework.batch.item.database.support.SqlPagingQueryProviderFactoryBean;
import org.springframework.batch.item.database.support.AbstractSqlPagingQueryProvider;
import org.springframework.batch.item.database.support.H2PagingQueryProvider;
import org.springframework.batch.item.database.BeanPropertyRowMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.batch.core.configuration.annotation.StepScope;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

@Configuration
public class TxnSourceReaderConfig {

  @Bean
  @StepScope
  public JdbcPagingItemReader<TxnSourceRow> txnSourceReader(
      DataSource dataSource,
      @Value("#{jobParameters['invoiceDate']}") String invoiceDateStr
  ) {
    if (invoiceDateStr == null || invoiceDateStr.isBlank()) {
      invoiceDateStr = "2026-01-24";
    }

    Map<String, Object> params = new HashMap<>();
    params.put("invoiceDate", java.sql.Date.valueOf(invoiceDateStr));

    H2PagingQueryProvider queryProvider = new H2PagingQueryProvider();
    queryProvider.setSelectClause(
        "SELECT s.txn_id AS txnId, s.customer_id AS customerId, s.product_id AS productId, " +
        "       s.txn_amount AS txnAmount, s.invoice_date AS invoiceDate, " +
        "       c.discount_rate AS discountRate, p.tax_rate AS taxRate"
    );
    queryProvider.setFromClause(
        "FROM TXN_SOURCE s " +
        "LEFT JOIN CUSTOMER c ON c.customer_id = s.customer_id " +
        "LEFT JOIN PRODUCT  p ON p.product_id  = s.product_id"
    );
    queryProvider.setWhereClause("WHERE s.invoice_date = :invoiceDate AND s.status = 'N'");
    queryProvider.setSortKeys(Map.of("s.txn_id", Order.ASCENDING));

    JdbcPagingItemReader<TxnSourceRow> reader = new JdbcPagingItemReader<>();
    reader.setDataSource(dataSource);
    reader.setQueryProvider(queryProvider);
    reader.setParameterValues(params);
    reader.setPageSize(10);
    reader.setRowMapper(new BeanPropertyRowMapper<>(TxnSourceRow.class));
    return reader;
  }
}
package com.optum.fads.caseentrybatch.poc.batch;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.math.RoundingMode;

@Component
public class TxnProcessor implements ItemProcessor<TxnSourceRow, ProcessedTxn> {
  private static final Logger log = LoggerFactory.getLogger(TxnProcessor.class);

  @Value("#{jobParameters['runId']}")
  private String runId;

  @Override
  public ProcessedTxn process(TxnSourceRow row) {
    if (runId == null || runId.isBlank()) {
      runId = "RUN_2026-01-24_FALLBACK";
    }

    // validation
    if (row.txnAmount == null) {
      log.debug("TXN {} invalid: AMOUNT_NULL", row.txnId);
      return ProcessedTxn.error(runId, row, "AMOUNT_NULL");
    }
    if (row.txnAmount.compareTo(BigDecimal.ZERO) < 0) {
      log.debug("TXN {} invalid: AMOUNT_NEGATIVE", row.txnId);
      return ProcessedTxn.error(runId, row, "AMOUNT_NEGATIVE");
    }
    if (row.discountRate == null) {
      log.debug("TXN {} invalid: CUSTOMER_NOT_FOUND", row.txnId);
      return ProcessedTxn.error(runId, row, "CUSTOMER_NOT_FOUND");
    }
    if (row.taxRate == null) {
      log.debug("TXN {} invalid: PRODUCT_NOT_FOUND", row.txnId);
      return ProcessedTxn.error(runId, row, "PRODUCT_NOT_FOUND");
    }

    // calculations
    BigDecimal base = row.txnAmount;

    BigDecimal discount = base.multiply(row.discountRate).setScale(2, RoundingMode.HALF_UP);
    BigDecimal taxable = base.subtract(discount);

    BigDecimal tax = taxable.multiply(row.taxRate).setScale(2, RoundingMode.HALF_UP);
    BigDecimal commission = base.multiply(new BigDecimal("0.02")).setScale(2, RoundingMode.HALF_UP);

    BigDecimal net = taxable.add(tax).add(commission).setScale(2, RoundingMode.HALF_UP);

    log.debug("TXN {} OK: base={} discount={} tax={} commission={} net={}", row.txnId, base, discount, tax, commission, net);

    return ProcessedTxn.good(runId, row, discount, tax, commission, net);
  }
}


package com.optum.fads.caseentrybatch.poc.batch;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Component
public class RoutingWriter implements ItemWriter<ProcessedTxn> {
  private static final Logger log = LoggerFactory.getLogger(RoutingWriter.class);

  private final JdbcTemplate jdbc;

  public RoutingWriter(JdbcTemplate jdbc) {
    this.jdbc = jdbc;
  }

  @Override
  public void write(List<? extends ProcessedTxn> items) {
    List<ProcessedTxn> goods = new ArrayList<>();
    List<ProcessedTxn> errors = new ArrayList<>();

    for (ProcessedTxn p : items) {
      if (p.kind == ProcessedTxn.Kind.GOOD) goods.add(p);
      else errors.add(p);
    }

    Timestamp now = Timestamp.valueOf(LocalDateTime.now());

    // GOOD: stage + final + source D
    if (!goods.isEmpty()) {
      log.debug("Writer: writing {} GOOD items", goods.size());

      jdbc.batchUpdate(
          "INSERT INTO TXN_STAGE(run_id, invoice_date, txn_id, customer_id, product_id, base_amount, discount_rate, tax_rate, discount, tax, commission, net_amount, created_at) " +
              "VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)",
          goods,
          goods.size(),
          (ps, p) -> {
            ps.setString(1, p.runId);
            ps.setDate(2, java.sql.Date.valueOf(p.invoiceDate));
            ps.setLong(3, p.txnId);
            ps.setString(4, p.customerId);
            ps.setString(5, p.productId);
            ps.setBigDecimal(6, p.baseAmount);
            ps.setBigDecimal(7, p.discountRate);
            ps.setBigDecimal(8, p.taxRate);
            ps.setBigDecimal(9, p.discount);
            ps.setBigDecimal(10, p.tax);
            ps.setBigDecimal(11, p.commission);
            ps.setBigDecimal(12, p.netAmount);
            ps.setTimestamp(13, now);
          }
      );

      jdbc.batchUpdate(
          "INSERT INTO FINAL_TXN_LINE(txn_id, run_id, invoice_date, customer_id, base_amount, discount, tax, commission, net_amount, created_at) " +
              "VALUES (?,?,?,?,?,?,?,?,?,?)",
          goods,
          goods.size(),
          (ps, p) -> {
            ps.setLong(1, p.txnId);
            ps.setString(2, p.runId);
            ps.setDate(3, java.sql.Date.valueOf(p.invoiceDate));
            ps.setString(4, p.customerId);
            ps.setBigDecimal(5, p.baseAmount);
            ps.setBigDecimal(6, p.discount);
            ps.setBigDecimal(7, p.tax);
            ps.setBigDecimal(8, p.commission);
            ps.setBigDecimal(9, p.netAmount);
            ps.setTimestamp(10, now);
          }
      );

      jdbc.batchUpdate(
          "UPDATE TXN_SOURCE SET status='D', run_id=? WHERE txn_id=?",
          goods,
          goods.size(),
          (ps, p) -> {
            ps.setString(1, p.runId);
            ps.setLong(2, p.txnId);
          }
      );
    }

    // ERROR: error table + source E
    if (!errors.isEmpty()) {
      log.debug("Writer: writing {} ERROR items", errors.size());

      jdbc.batchUpdate(
          "INSERT INTO TXN_ERROR(run_id, invoice_date, txn_id, customer_id, product_id, txn_amount, error_reason, created_at) " +
              "VALUES (?,?,?,?,?,?,?,?)",
          errors,
          errors.size(),
          (ps, p) -> {
            ps.setString(1, p.runId);
            ps.setDate(2, java.sql.Date.valueOf(p.invoiceDate));
            ps.setLong(3, p.txnId);
            ps.setString(4, p.customerId);
            ps.setString(5, p.productId);
            if (p.baseAmount == null) ps.setNull(6, java.sql.Types.DECIMAL);
            else ps.setBigDecimal(6, p.baseAmount);
            ps.setString(7, p.errorReason);
            ps.setTimestamp(8, now);
          }
      );

      jdbc.batchUpdate(
          "UPDATE TXN_SOURCE SET status='E', run_id=? WHERE txn_id=?",
          errors,
          errors.size(),
          (ps, p) -> {
            ps.setString(1, p.runId);
            ps.setLong(2, p.txnId);
          }
      );
    }
  }
}


package com.optum.fads.caseentrybatch.poc.batch;

import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.BeanPropertyRowMapper;

import javax.sql.DataSource;

@Configuration
public class InvoiceAggregationConfig {

  @Bean
  @StepScope
  public JdbcCursorItemReader<InvoiceSummary> invoiceSummaryReader(
      DataSource dataSource,
      @Value("#{jobParameters['runId']}") String runId,
      @Value("#{jobParameters['invoiceDate']}") String invoiceDateStr
  ) {
    if (invoiceDateStr == null || invoiceDateStr.isBlank()) {
      invoiceDateStr = "2026-01-24";
    }

    String sql =
        "SELECT run_id AS runId, customer_id AS customerId, invoice_date AS invoiceDate, " +
        "       ROUND(SUM(base_amount),2) AS totalGross, " +
        "       ROUND(SUM(discount),2) AS totalDiscount, " +
        "       ROUND(SUM(tax),2) AS totalTax, " +
        "       ROUND(SUM(commission),2) AS totalCommission, " +
        "       ROUND(SUM(net_amount),2) AS totalNet " +
        "FROM FINAL_TXN_LINE " +
        "WHERE run_id = ? AND invoice_date = ? " +
        "GROUP BY run_id, customer_id, invoice_date " +
        "ORDER BY customer_id";

    return new JdbcCursorItemReaderBuilder<InvoiceSummary>()
        .name("invoiceSummaryReader")
        .dataSource(dataSource)
        .sql(sql)
        .preparedStatementSetter(ps -> {
          ps.setString(1, runId);
          ps.setDate(2, java.sql.Date.valueOf(invoiceDateStr));
        })
        .rowMapper(new BeanPropertyRowMapper<>(InvoiceSummary.class))
        .build();
  }

  @Bean
  public JdbcBatchItemWriter<InvoiceSummary> invoiceWriter(DataSource dataSource) {
    return new JdbcBatchItemWriterBuilder<InvoiceSummary>()
        .dataSource(dataSource)
        .sql("INSERT INTO INVOICE_FINAL(run_id, customer_id, invoice_date, total_gross, total_discount, total_tax, total_commission, total_net, created_at) " +
             "VALUES (?,?,?,?,?,?,?,?, CURRENT_TIMESTAMP)")
        .itemPreparedStatementSetter((ps, i) -> {
          ps.setString(1, i.runId);
          ps.setString(2, i.customerId);
          ps.setDate(3, java.sql.Date.valueOf(i.invoiceDate));
          ps.setBigDecimal(4, i.totalGross);
          ps.setBigDecimal(5, i.totalDiscount);
          ps.setBigDecimal(6, i.totalTax);
          ps.setBigDecimal(7, i.totalCommission);
          ps.setBigDecimal(8, i.totalNet);
        })
        .build();
  }
}


package com.optum.fads.caseentrybatch.poc.batch;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.item.database.JdbcPagingItemReader;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableBatchProcessing
public class InvoiceJobConfig {

  @Bean
  public Job invoiceJob(JobBuilderFactory jobs,
                        StepBuilderFactory steps,
                        JdbcPagingItemReader<TxnSourceRow> txnSourceReader,
                        TxnProcessor txnProcessor,
                        RoutingWriter routingWriter,
                        Step invoiceAggregationStep) {

    Step txnProcessingStep =
        steps.get("txnProcessingStep")
            .<TxnSourceRow, ProcessedTxn>chunk(10)
            .reader(txnSourceReader)
            .processor(txnProcessor)
            .writer(routingWriter)
            .build();

    return jobs.get("invoiceJob")
        .incrementer(new RunIdIncrementerWithRunId())
        .start(txnProcessingStep)
        .next(invoiceAggregationStep)
        .build();
  }

  @Bean
  public Step invoiceAggregationStep(StepBuilderFactory steps,
                                    org.springframework.batch.item.database.JdbcCursorItemReader<InvoiceSummary> invoiceSummaryReader,
                                    JdbcBatchItemWriter<InvoiceSummary> invoiceWriter) {

    return steps.get("invoiceAggregationStep")
        .<InvoiceSummary, InvoiceSummary>chunk(50)
        .reader(invoiceSummaryReader)
        .writer(invoiceWriter)
        .build();
  }
}
