package com.optum.fads.pgp.jobs.api.config;

import com.optum.fads.pgp.jobs.api.service.IUserDetailsService;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;

import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Base64;

import static org.junit.jupiter.api.Assertions.*;

class SecurityConfigTest {

    @Test
    void passwordEncoder_shouldCreate() {
        IUserDetailsService uds = Mockito.mock(IUserDetailsService.class);
        SecurityConfig cfg = new SecurityConfig(uds);

        PasswordEncoder encoder = cfg.passwordEncoder();

        assertNotNull(encoder);
        assertTrue(encoder.matches("pass", encoder.encode("pass")));
    }

    @Test
    void corsConfigurationSource_shouldAllowAll() {
        IUserDetailsService uds = Mockito.mock(IUserDetailsService.class);
        SecurityConfig cfg = new SecurityConfig(uds);

        CorsConfigurationSource source = cfg.corsConfigurationSource();
        assertNotNull(source);

        CorsConfiguration conf = source.getCorsConfiguration(null);
        assertNotNull(conf);

        // You configured ALL for origins/methods/headers
        assertTrue(conf.getAllowedOrigins() == null || conf.getAllowedOrigins().contains("*"));
        assertTrue(conf.getAllowedMethods() == null || conf.getAllowedMethods().contains("*"));
        assertTrue(conf.getAllowedHeaders() == null || conf.getAllowedHeaders().contains("*"));
    }

    @Test
    void jwtDecoder_shouldConvertTimeClaimsToInstant_includingAuthTimeNumber() {
        IUserDetailsService uds = Mockito.mock(IUserDetailsService.class);
        SecurityConfig cfg = new SecurityConfig(uds);

        JwtDecoder decoder = cfg.jwtDecoder();

        // alg=none JWT so Nimbus JWTParser can parse it:
        long now = Instant.now().getEpochSecond();

        String token = unsignedJwt(MapJson.of(
                "sub", "user1",
                "iat", now,               // Number -> should become Instant
                "exp", now + 3600,        // Number -> should become Instant
                "nbf", now - 10,          // Number -> should become Instant
                "auth_time", now - 100    // Number -> should become Instant (this was your failing case)
        ));

        Jwt jwt = decoder.decode(token);

        assertNotNull(jwt);
        assertEquals("user1", jwt.getClaimAsString("sub"));

        assertTrue(jwt.getClaim("iat") instanceof Instant, "iat should be Instant");
        assertTrue(jwt.getClaim("exp") instanceof Instant, "exp should be Instant");
        assertTrue(jwt.getClaim("nbf") instanceof Instant, "nbf should be Instant");
        assertTrue(jwt.getClaim("auth_time") instanceof Instant, "auth_time should be Instant");
    }

    // ---- helpers ----

    /** Creates an unsigned JWT (alg=none): header.payload. */
    private static String unsignedJwt(String payloadJson) {
        String headerJson = "{\"alg\":\"none\",\"typ\":\"JWT\"}";
        return b64Url(headerJson) + "." + b64Url(payloadJson) + ".";
    }

    private static String b64Url(String s) {
        return Base64.getUrlEncoder().withoutPadding()
                .encodeToString(s.getBytes(StandardCharsets.UTF_8));
    }

    /** tiny JSON builder for test payloads */
    static class MapJson {
        static String of(Object... kv) {
            StringBuilder sb = new StringBuilder("{");
            for (int i = 0; i < kv.length; i += 2) {
                if (i > 0) sb.append(",");
                String k = String.valueOf(kv[i]);
                Object v = kv[i + 1];
                sb.append("\"").append(k).append("\":");
                if (v instanceof Number || v instanceof Boolean) {
                    sb.append(v);
                } else {
                    sb.append("\"").append(escape(String.valueOf(v))).append("\"");
                }
            }
            sb.append("}");
            return sb.toString();
        }

        private static String escape(String s) {
            return s.replace("\\", "\\\\").replace("\"", "\\\"");
        }
    }
}
