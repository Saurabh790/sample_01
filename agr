package com.optum.fads.caseentrybatch.poc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class InvoiceBatchApplication {
  public static void main(String[] args) {
    SpringApplication.run(InvoiceBatchApplication.class, args);
  }
}
package com.optum.fads.caseentrybatch.poc.batch;



import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.PreparedStatementSetter;

/**
 * Reads aggregated invoice data from FINAL_TXN_LINE and produces
 * one row per (run_id, customer_id, invoice_date).
 *
 * IMPORTANT:
 * 1. We use COALESCE around SUM() so NULL values never propagate.
 * 2. This guarantees inserts into INVOICE_FINAL never fail due to NULL totals.
 * 3. This is the final stabilization layer of your batch pipeline.
 */
@Configuration
public class InvoiceAggregationConfig {

    @Bean
    @StepScope
    public JdbcCursorItemReader<InvoiceSummary> invoiceSummaryReader(
            DataSource dataSource,
            @Value("#{jobParameters['runId']}") String runId,
            @Value("#{jobParameters['invoiceDate']}") String invoiceDateStr
    ) {

        final String effectiveRunId = runId;
        final String effectiveInvoiceDate =
                (invoiceDateStr == null || invoiceDateStr.isBlank())
                        ? "2026-01-24"
                        : invoiceDateStr;

        String sql =
            "SELECT run_id AS runId, " +
            "       customer_id AS customerId, " +
            "       invoice_date AS invoiceDate, " +

            // ---- Use COALESCE to prevent NULL totals ----
            "       ROUND(COALESCE(SUM(base_amount),0),2)      AS totalGross, " +
            "       ROUND(COALESCE(SUM(discount),0),2)         AS totalDiscount, " +
            "       ROUND(COALESCE(SUM(tax),0),2)              AS totalTax, " +
            "       ROUND(COALESCE(SUM(commission),0),2)       AS totalCommission, " +
            "       ROUND(COALESCE(SUM(net_amount),0),2)       AS totalNet " +

            "FROM FINAL_TXN_LINE " +
            "WHERE run_id = ? AND invoice_date = ? " +
            "GROUP BY run_id, customer_id, invoice_date " +
            "ORDER BY customer_id";

        PreparedStatementSetter pss = new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                ps.setString(1, effectiveRunId);
                ps.setDate(2, Date.valueOf(effectiveInvoiceDate));
            }
        };

        return new JdbcCursorItemReaderBuilder<InvoiceSummary>()
                .name("invoiceSummaryReader")
                .dataSource(dataSource)
                .sql(sql)
                .preparedStatementSetter(pss)
                .rowMapper(new BeanPropertyRowMapper<>(InvoiceSummary.class))
                .build();
    }
}
package com.optum.fads.caseentrybatch.poc.batch;

import javax.sql.DataSource;

import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class InvoiceAggregationWriterConfig {

  @Bean
  public JdbcBatchItemWriter<InvoiceSummary> invoiceFinalWriter(DataSource dataSource) {
    return new JdbcBatchItemWriterBuilder<InvoiceSummary>()
        .dataSource(dataSource)
        .sql(
            "INSERT INTO INVOICE_FINAL(run_id, customer_id, invoice_date, total_gross, total_discount, total_tax, total_commission, total_net, created_at) " +
            "VALUES (:runId, :customerId, :invoiceDate, :totalGross, :totalDiscount, :totalTax, :totalCommission, :totalNet, CURRENT_TIMESTAMP)"
        )
        .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())
        .build();
  }
}
package com.optum.fads.caseentrybatch.poc.batch;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.sql.Date;
import java.time.LocalDate;

import javax.sql.DataSource;

import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepScope;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;
import org.springframework.batch.item.database.JdbcBatchItemWriter;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;
import org.springframework.batch.item.database.builder.JdbcCursorItemReaderBuilder;
import org.springframework.batch.item.support.CompositeItemWriter;
import org.springframework.batch.item.support.builder.CompositeItemWriterBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.BeanPropertyRowMapper;

@Configuration
@EnableBatchProcessing
public class InvoiceJobConfig {

  private static final int CHUNK_SIZE = 10;

  @Bean
  public Job invoiceJob(JobBuilderFactory jobs,
                        Step processTxnStep,
                        Step invoiceAggregationStep,
                        RunIdIncrementerWithRunId runIdIncrementerWithRunId) {
    return jobs.get("invoiceJob")
        .incrementer(runIdIncrementerWithRunId)
        .start(processTxnStep)
        .next(invoiceAggregationStep)
        .build();
  }

  @Bean
  public Step processTxnStep(
      StepBuilderFactory steps,
      JdbcCursorItemReader<TxnSource> txnReader,
      ItemProcessor<TxnSource, ProcessedTxn> txnProcessor,
      CompositeItemWriter<ProcessedTxn> routingWriter
  ) {
    return steps.get("processTxnStep")
        .<TxnSource, ProcessedTxn>chunk(CHUNK_SIZE)
        .reader(txnReader)
        .processor(txnProcessor)
        .writer(routingWriter)
        .build();
  }

  // ---------------- Reader (joins for enrichment) ----------------

  @Bean
  @StepScope
  public JdbcCursorItemReader<TxnSource> txnReader(
      DataSource dataSource,
      @Value("#{jobParameters['invoiceDate']}") String invoiceDateStr
  ) {
    LocalDate invoiceDate = (invoiceDateStr == null || invoiceDateStr.isBlank())
        ? LocalDate.of(2026, 1, 24)
        : LocalDate.parse(invoiceDateStr);

    String sql =
        "SELECT s.txn_id      AS txnId, " +
        "       s.customer_id AS customerId, " +
        "       s.product_id  AS productId, " +
        "       s.txn_amount  AS txnAmount, " +
        "       s.invoice_date AS invoiceDate, " +
        "       c.discount_rate AS discountRate, " +
        "       p.tax_rate AS taxRate " +
        "FROM TXN_SOURCE s " +
        "LEFT JOIN CUSTOMER c ON c.customer_id = s.customer_id " +
        "LEFT JOIN PRODUCT  p ON p.product_id  = s.product_id " +
        "WHERE s.invoice_date = ? AND s.status = 'N' " +
        "ORDER BY s.txn_id";

    return new JdbcCursorItemReaderBuilder<TxnSource>()
        .name("txnReader")
        .dataSource(dataSource)
        .sql(sql)
        .preparedStatementSetter(ps -> ps.setDate(1, Date.valueOf(invoiceDate)))
        .rowMapper(new BeanPropertyRowMapper<>(TxnSource.class))
        .build();
  }

  // ---------------- Processor ----------------

  @Bean
  @StepScope
  public ItemProcessor<TxnSource, ProcessedTxn> txnProcessor(
      @Value("#{jobParameters['runId']}") String runId
  ) {
    final String effectiveRunId = (runId == null || runId.isBlank())
        ? "RUN_" + System.currentTimeMillis()
        : runId;

    return s -> {
      BigDecimal base = s.getTxnAmount();
      if (base == null) return ProcessedTxn.error(effectiveRunId, s, "AMOUNT_NULL");
      if (base.compareTo(BigDecimal.ZERO) < 0) return ProcessedTxn.error(effectiveRunId, s, "AMOUNT_NEGATIVE");
      if (s.getDiscountRate() == null) return ProcessedTxn.error(effectiveRunId, s, "CUSTOMER_NOT_FOUND");
      if (s.getTaxRate() == null) return ProcessedTxn.error(effectiveRunId, s, "PRODUCT_NOT_FOUND");

      // rules:
      // discount = base * discount_rate
      // tax = (base-discount) * tax_rate
      // commission = base * 0.02
      // net = (base-discount) + tax + commission

      BigDecimal discount = base.multiply(s.getDiscountRate()).setScale(2, RoundingMode.HALF_UP);
      BigDecimal taxable = base.subtract(discount);
      BigDecimal tax = taxable.multiply(s.getTaxRate()).setScale(2, RoundingMode.HALF_UP);
      BigDecimal commission = base.multiply(new BigDecimal("0.02")).setScale(2, RoundingMode.HALF_UP);
      BigDecimal net = taxable.add(tax).add(commission).setScale(2, RoundingMode.HALF_UP);

      return ProcessedTxn.good(effectiveRunId, s, discount, tax, commission, net);
    };
  }

  // ---------------- Writers ----------------

  @Bean
  public CompositeItemWriter<ProcessedTxn> routingWriter(
      JdbcBatchItemWriter<ProcessedTxn> stageWriter,
      JdbcBatchItemWriter<ProcessedTxn> finalLineWriter,
      JdbcBatchItemWriter<ProcessedTxn> errorWriter,
      TxnStatusUpdateWriter statusWriter
  ) {
    return new CompositeItemWriterBuilder<ProcessedTxn>()
        .delegates(stageWriter, finalLineWriter, errorWriter, statusWriter)
        .build();
  }

  // GOOD -> TXN_STAGE
  @Bean
  public JdbcBatchItemWriter<ProcessedTxn> stageWriter(DataSource dataSource) {
    return new JdbcBatchItemWriterBuilder<ProcessedTxn>()
        .dataSource(dataSource)
        .sql(
            "INSERT INTO TXN_STAGE(run_id, invoice_date, txn_id, customer_id, product_id, base_amount, discount_rate, tax_rate, " +
            "discount, tax, commission, net_amount, created_at) " +
            "VALUES (:runId, :invoiceDate, :txnId, :customerId, :productId, :baseAmount, :discountRate, :taxRate, " +
            ":discount, :tax, :commission, :netAmount, CURRENT_TIMESTAMP)"
        )
        .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())
        .assertUpdates(false)
        .build();
  }

  // GOOD -> FINAL_TXN_LINE
  @Bean
  public JdbcBatchItemWriter<ProcessedTxn> finalLineWriter(DataSource dataSource) {
    return new JdbcBatchItemWriterBuilder<ProcessedTxn>()
        .dataSource(dataSource)
        .sql(
            "INSERT INTO FINAL_TXN_LINE(txn_id, run_id, invoice_date, customer_id, base_amount, discount, tax, commission, net_amount, created_at) " +
            "VALUES (:txnId, :runId, :invoiceDate, :customerId, :baseAmount, :discount, :tax, :commission, :netAmount, CURRENT_TIMESTAMP)"
        )
        .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())
        .assertUpdates(false)
        .build();
  }

  // ERROR -> TXN_ERROR (only when kind=ERROR; writer will skip others)
  @Bean
  public JdbcBatchItemWriter<ProcessedTxn> errorWriter(DataSource dataSource) {
    return new JdbcBatchItemWriterBuilder<ProcessedTxn>()
        .dataSource(dataSource)
        .sql(
            "INSERT INTO TXN_ERROR(run_id, invoice_date, txn_id, customer_id, product_id, txn_amount, error_reason, created_at) " +
            "VALUES (:runId, :invoiceDate, :txnId, :customerId, :productId, :baseAmount, :errorReason, CURRENT_TIMESTAMP)"
        )
        .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider<>())
        .assertUpdates(false)
        .build();
  }

  // ---------------- Aggregation step wire-up ----------------

  @Bean
  public Step invoiceAggregationStep(
      StepBuilderFactory steps,
      JdbcCursorItemReader<InvoiceSummary> invoiceSummaryReader,
      JdbcBatchItemWriter<InvoiceSummary> invoiceFinalWriter
  ) {
    return steps.get("invoiceAggregationStep")
        .<InvoiceSummary, InvoiceSummary>chunk(50)
        .reader(invoiceSummaryReader)
        .writer(invoiceFinalWriter)
        .build();
  }

  @Bean
  public RunIdIncrementerWithRunId runIdIncrementerWithRunId() {
    return new RunIdIncrementerWithRunId();
  }
}
package com.optum.fads.caseentrybatch.poc.batch;

import java.math.BigDecimal;
import java.sql.Date;

public class InvoiceSummary {
  private String runId;
  private String customerId;
  private Date invoiceDate;

  private BigDecimal totalGross;
  private BigDecimal totalDiscount;
  private BigDecimal totalTax;
  private BigDecimal totalCommission;
  private BigDecimal totalNet;

  public String getRunId() { return runId; }
  public void setRunId(String runId) { this.runId = runId; }

  public String getCustomerId() { return customerId; }
  public void setCustomerId(String customerId) { this.customerId = customerId; }

  public Date getInvoiceDate() { return invoiceDate; }
  public void setInvoiceDate(Date invoiceDate) { this.invoiceDate = invoiceDate; }

  public BigDecimal getTotalGross() { return totalGross; }
  public void setTotalGross(BigDecimal totalGross) { this.totalGross = totalGross; }

  public BigDecimal getTotalDiscount() { return totalDiscount; }
  public void setTotalDiscount(BigDecimal totalDiscount) { this.totalDiscount = totalDiscount; }

  public BigDecimal getTotalTax() { return totalTax; }
  public void setTotalTax(BigDecimal totalTax) { this.totalTax = totalTax; }

  public BigDecimal getTotalCommission() { return totalCommission; }
  public void setTotalCommission(BigDecimal totalCommission) { this.totalCommission = totalCommission; }

  public BigDecimal getTotalNet() { return totalNet; }
  public void setTotalNet(BigDecimal totalNet) { this.totalNet = totalNet; }
}
package com.optum.fads.caseentrybatch.poc.batch;

import java.math.BigDecimal;
import java.sql.Date;

public class ProcessedTxn {

  public enum Kind { GOOD, ERROR }

  private Kind kind;

  private Long txnId;
  private String runId;
  private Date invoiceDate;

  private String customerId;
  private String productId;

  private BigDecimal baseAmount;
  private BigDecimal discountRate;
  private BigDecimal taxRate;

  private BigDecimal discount;
  private BigDecimal tax;
  private BigDecimal commission;
  private BigDecimal netAmount;

  private String errorReason;

  public static ProcessedTxn good(String runId, TxnSource s,
                                  BigDecimal discount, BigDecimal tax,
                                  BigDecimal commission, BigDecimal net) {
    ProcessedTxn p = new ProcessedTxn();
    p.kind = Kind.GOOD;
    p.runId = runId;
    p.invoiceDate = s.getInvoiceDate();
    p.txnId = s.getTxnId();
    p.customerId = s.getCustomerId();
    p.productId = s.getProductId();
    p.baseAmount = s.getTxnAmount();
    p.discountRate = s.getDiscountRate();
    p.taxRate = s.getTaxRate();
    p.discount = discount;
    p.tax = tax;
    p.commission = commission;
    p.netAmount = net;
    return p;
  }

  public static ProcessedTxn error(String runId, TxnSource s, String reason) {
    ProcessedTxn p = new ProcessedTxn();
    p.kind = Kind.ERROR;
    p.runId = runId;
    p.invoiceDate = s.getInvoiceDate();
    p.txnId = s.getTxnId();
    p.customerId = s.getCustomerId();
    p.productId = s.getProductId();
    p.baseAmount = s.getTxnAmount();
    p.errorReason = reason;
    return p;
  }

  public Kind getKind() { return kind; }

  public Long getTxnId() { return txnId; }
  public void setTxnId(Long txnId) { this.txnId = txnId; }

  public String getRunId() { return runId; }
  public void setRunId(String runId) { this.runId = runId; }

  public Date getInvoiceDate() { return invoiceDate; }
  public void setInvoiceDate(Date invoiceDate) { this.invoiceDate = invoiceDate; }

  public String getCustomerId() { return customerId; }
  public void setCustomerId(String customerId) { this.customerId = customerId; }

  public String getProductId() { return productId; }
  public void setProductId(String productId) { this.productId = productId; }

  public BigDecimal getBaseAmount() { return baseAmount; }
  public void setBaseAmount(BigDecimal baseAmount) { this.baseAmount = baseAmount; }

  public BigDecimal getDiscountRate() { return discountRate; }
  public void setDiscountRate(BigDecimal discountRate) { this.discountRate = discountRate; }

  public BigDecimal getTaxRate() { return taxRate; }
  public void setTaxRate(BigDecimal taxRate) { this.taxRate = taxRate; }

  public BigDecimal getDiscount() { return discount; }
  public void setDiscount(BigDecimal discount) { this.discount = discount; }

  public BigDecimal getTax() { return tax; }
  public void setTax(BigDecimal tax) { this.tax = tax; }

  public BigDecimal getCommission() { return commission; }
  public void setCommission(BigDecimal commission) { this.commission = commission; }

  public BigDecimal getNetAmount() { return netAmount; }
  public void setNetAmount(BigDecimal netAmount) { this.netAmount = netAmount; }

  public String getErrorReason() { return errorReason; }
  public void setErrorReason(String errorReason) { this.errorReason = errorReason; }
}
package com.optum.fads.caseentrybatch.poc.batch;

import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.JobParametersIncrementer;
import org.springframework.batch.core.launch.support.RunIdIncrementer;

import java.time.LocalDateTime;

public class RunIdIncrementerWithRunId implements JobParametersIncrementer {
  private final RunIdIncrementer delegate = new RunIdIncrementer();

  @Override
  public JobParameters getNext(JobParameters parameters) {
    JobParameters next = delegate.getNext(parameters);

    String invoiceDate = (parameters == null) ? null : parameters.getString("invoiceDate");
    if (invoiceDate == null || invoiceDate.isBlank()) {
      invoiceDate = "2026-01-24"; // default for demo
    }

    String runId = "RUN_" + invoiceDate + "_" + LocalDateTime.now().toString();

    return new JobParametersBuilder(next)
        .addString("invoiceDate", invoiceDate, true)
        .addString("runId", runId, true)
        .toJobParameters();
  }
}
package com.optum.fads.caseentrybatch.poc.batch;

import java.math.BigDecimal;
import java.sql.Date;

public class TxnSource {
  private Long txnId;
  private String customerId;
  private String productId;
  private BigDecimal txnAmount;
  private Date invoiceDate;

  // from joins
  private BigDecimal discountRate;
  private BigDecimal taxRate;

  public Long getTxnId() { return txnId; }
  public void setTxnId(Long txnId) { this.txnId = txnId; }

  public String getCustomerId() { return customerId; }
  public void setCustomerId(String customerId) { this.customerId = customerId; }

  public String getProductId() { return productId; }
  public void setProductId(String productId) { this.productId = productId; }

  public BigDecimal getTxnAmount() { return txnAmount; }
  public void setTxnAmount(BigDecimal txnAmount) { this.txnAmount = txnAmount; }

  public Date getInvoiceDate() { return invoiceDate; }
  public void setInvoiceDate(Date invoiceDate) { this.invoiceDate = invoiceDate; }

  public BigDecimal getDiscountRate() { return discountRate; }
  public void setDiscountRate(BigDecimal discountRate) { this.discountRate = discountRate; }

  public BigDecimal getTaxRate() { return taxRate; }
  public void setTaxRate(BigDecimal taxRate) { this.taxRate = taxRate; }
}
package com.optum.fads.caseentrybatch.poc.batch;

import java.util.List;
import java.util.stream.Collectors;

import javax.sql.DataSource;

import org.springframework.batch.item.ItemWriter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class TxnStatusUpdateWriter implements ItemWriter<ProcessedTxn> {

  private final JdbcTemplate jdbc;

  public TxnStatusUpdateWriter(DataSource dataSource) {
    this.jdbc = new JdbcTemplate(dataSource);
  }

  @Override
  public void write(List<? extends ProcessedTxn> items) {
    List<ProcessedTxn> good = items.stream()
        .filter(i -> i.getKind() == ProcessedTxn.Kind.GOOD)
        .collect(Collectors.toList());

    for (ProcessedTxn p : good) {
      jdbc.update("UPDATE TXN_SOURCE SET status='D', run_id=? WHERE txn_id=?",
          p.getRunId(), p.getTxnId());
    }

    List<ProcessedTxn> err = items.stream()
        .filter(i -> i.getKind() == ProcessedTxn.Kind.ERROR)
        .collect(Collectors.toList());

    for (ProcessedTxn p : err) {
      jdbc.update("UPDATE TXN_SOURCE SET status='E', run_id=? WHERE txn_id=?",
          p.getRunId(), p.getTxnId());
    }
  }
}

spring:
  datasource:
    url: jdbc:h2:mem:batchdb;DB_CLOSE_DELAY=-1
    driverClassName: org.h2.Driver
    username: sa
    password:

  sql:
    init:
      mode: always

  h2:
    console:
      enabled: true
      path: /h2-console

  batch:
    jdbc:
      initialize-schema: always
    job:
      enabled: true

logging:
  file:
    name: logs/invoice-batch.log
  level:
    root: INFO
    com.optum.fads: DEBUG
    org.springframework.batch: INFO


DROP TABLE IF EXISTS TXN_SOURCE;
DROP TABLE IF EXISTS CUSTOMER;
DROP TABLE IF EXISTS PRODUCT;
DROP TABLE IF EXISTS TXN_STAGE;
DROP TABLE IF EXISTS FINAL_TXN_LINE;
DROP TABLE IF EXISTS INVOICE_FINAL;
DROP TABLE IF EXISTS TXN_ERROR;

CREATE TABLE CUSTOMER (
  customer_id VARCHAR(20) PRIMARY KEY,
  discount_rate DECIMAL(5,2) NOT NULL
);

CREATE TABLE PRODUCT (
  product_id VARCHAR(20) PRIMARY KEY,
  tax_rate DECIMAL(5,2) NOT NULL
);

-- status: N=new, D=done, E=error
CREATE TABLE TXN_SOURCE (
  txn_id BIGINT PRIMARY KEY,
  customer_id VARCHAR(20),
  product_id VARCHAR(20),
  txn_amount DECIMAL(18,2),
  txn_time TIMESTAMP NOT NULL,
  currency VARCHAR(10) NOT NULL,
  channel VARCHAR(10) NOT NULL,
  invoice_date DATE NOT NULL,
  status CHAR(1) DEFAULT 'N' NOT NULL,
  run_id VARCHAR(80)
);

CREATE INDEX IDX_TXN_SOURCE_DATE_STATUS ON TXN_SOURCE(invoice_date, status);

-- persistent staging (audit of GOOD rows)

CREATE TABLE TXN_STAGE (
  stage_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  run_id VARCHAR(80) NOT NULL,
  invoice_date DATE NOT NULL,
  txn_id BIGINT NOT NULL,
  customer_id VARCHAR(20),
  product_id VARCHAR(20),
  base_amount DECIMAL(18,2),

  -- allow NULLs for POC
  discount_rate DECIMAL(5,2),
  tax_rate DECIMAL(5,2),

  discount DECIMAL(18,2),
  tax DECIMAL(18,2),
  commission DECIMAL(18,2),
  net_amount DECIMAL(18,2),
  created_at TIMESTAMP NOT NULL
);


CREATE UNIQUE INDEX UX_STAGE_RUN_TXN ON TXN_STAGE(run_id, txn_id);

CREATE TABLE TXN_ERROR (
  error_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  run_id VARCHAR(80),
  invoice_date DATE,
  txn_id BIGINT,
  customer_id VARCHAR(20),
  product_id VARCHAR(20),
  txn_amount DECIMAL(18,2),
  error_reason VARCHAR(300),

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- final per-transaction computed output

CREATE TABLE FINAL_TXN_LINE (
  txn_id BIGINT PRIMARY KEY,
  run_id VARCHAR(80) NOT NULL,
  invoice_date DATE NOT NULL,
  customer_id VARCHAR(20),
  base_amount DECIMAL(18,2),

  discount DECIMAL(18,2) DEFAULT 0.00,
  tax DECIMAL(18,2) DEFAULT 0.00,
  commission DECIMAL(18,2) DEFAULT 0.00,
  net_amount DECIMAL(18,2) DEFAULT 0.00,

  created_at TIMESTAMP NOT NULL
);


CREATE INDEX IDX_FINAL_RUN ON FINAL_TXN_LINE(run_id);

-- aggregated invoice per customer/day
CREATE TABLE INVOICE_FINAL (
  invoice_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  run_id VARCHAR(80),
  customer_id VARCHAR(20),
  invoice_date DATE,

  total_gross DECIMAL(18,2) DEFAULT 0,
  total_discount DECIMAL(18,2) DEFAULT 0,
  total_tax DECIMAL(18,2) DEFAULT 0,
  total_commission DECIMAL(18,2) DEFAULT 0,
  total_net DECIMAL(18,2) DEFAULT 0,

  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IDX_INVOICE_RUN ON INVOICE_FINAL(run_id);

